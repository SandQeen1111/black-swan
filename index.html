<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Black Swan v16 OMEGA â€” Deutsche Programmiersprache</title>
<meta name="description" content="Black Swan: Die erste vollstÃ¤ndige deutsche Programmiersprache mit IDE. 12 Features: 3D, Physik, KI, Shader, Multiplayer und mehr.">
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>&#x1f9a2;</text></svg>">
<style>html,body,#root{margin:0;padding:0;height:100%;overflow:hidden;background:#050508}</style>
</head>
<body>
<div id="root"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"></script>
<script type="text/babel" data-presets="react">
const { useState, useEffect, useCallback, useRef } = React;
// THREE loaded via CDN

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  B L A C K  S W A N  v16 â€” OMEGA EDITION  â˜… COMPLETE ROADMAP â˜…
//  ğŸ‘¥ Multi Â· ğŸŒ Shader Â· ğŸ–ï¸ KÃ¶rper Â· ğŸ§  KI Â· ğŸ§Š 3D Â· âš›ï¸ Physik Â· ğŸ­ Partikel Â· ğŸ® Game
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const KW={wenn:"if",sonst_wenn:"elif",sonst:"else",solange:"while","fÃ¼r":"for",
abbrechen:"break",weiter:"continue",Ã¼bergeben:"pass",funktion:"def",
zurÃ¼ckgeben:"return",klasse:"class",selbst:"self",wahr:"True",falsch:"False",
und:"and",oder:"or",nicht:"not",ist:"is",nichts:"None",versuche:"try",
ausnahme:"except",schlieÃŸlich:"finally",importiere:"import",
von:"from",als:"as",mit:"with",anonym:"lambda","in":"in"};
const BF={drucke:"print",bereich:"range",lÃ¤nge:"len",ganzzahl:"int",
dezimal:"float",zeichenkette:"str",liste:"list",abs_wert:"abs",
runden:"round",sortiert:"sorted",minimum:"min",maximum:"max",summe:"sum"};
const ALL={...KW,...BF};
const MT={".anhÃ¤ngen(":".append(",".herausholen(":".pop(",".sortieren(":".sort(",
".umkehren(":".reverse(",".ersetzen(":".replace(",".teilen(":".split(",
".einfÃ¼gen(":".insert(",".entfernen(":".remove(",".groÃŸbuchstaben(":".upper(",
".kleinbuchstaben(":".lower(",".streifen(":".strip(",".finden(":".find(",
".zÃ¤hlen(":".count(",".verbinden(":".join(",".beginnt_mit(":".startswith(",
".endet_mit(":".endswith(",".schlÃ¼ssel(":".keys(",".werte(":".values("};

function protect(c){const s=[];const r=c.replace(/("""[\s\S]*?"""|'''[\s\S]*?'''|"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*'|#.*$)/gm,
m=>{s.push(m);return`\x00${s.length-1}\x00`});return{safe:r,strings:s}}
function restore(c,s){return c.replace(/\x00(\d+)\x00/g,(_,i)=>s[+i])}
const WB_S="(?<![a-zA-ZÃ¤Ã¶Ã¼Ã„Ã–ÃœÃŸ_0-9])",WB_E="(?![a-zA-ZÃ¤Ã¶Ã¼Ã„Ã–ÃœÃŸ_0-9])";
function deToEn(code){let{safe,strings}=protect(code);
for(const k of Object.keys(MT).sort((a,b)=>b.length-a.length))safe=safe.split(k).join(MT[k]);
for(const k of Object.keys(ALL).sort((a,b)=>b.length-a.length)){
const e=k.replace(/[.*+?^${}()|[\]\\]/g,'\\$&');
safe=safe.replace(new RegExp(`${WB_S}${e}${WB_E}`,"g"),ALL[k])}
return restore(safe,strings)}

// â”€â”€ EXECUTION ENGINE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function compileGerman(code){
let js="";const parsed=[];
for(const raw of code.split("\n")){const t=raw.trim();
if(!t||t.startsWith("#"))continue;
parsed.push({indent:Math.max(0,raw.search(/\S/)),text:t})}
const bs=[];
for(let i=0;i<parsed.length;i++){
const{indent,text}=parsed[i];
const isCont=/^(sonst_wenn\s|sonst:|ausnahme|schlieÃŸlich:)/.test(text);
if(!isCont){while(bs.length>0&&indent<=bs[bs.length-1]){bs.pop();js+="}\n"}}
else{while(bs.length>0&&indent<bs[bs.length-1]){bs.pop();js+="}\n"}
if(bs.length>0&&indent<=bs[bs.length-1])bs.pop()}
const line=tLine(text);
if(text.endsWith(":")){js+=line+"\n";bs.push(indent)}else{js+=line+";\n"}}
while(bs.length>0){bs.pop();js+="}\n"}
return js}

function tLine(t){let l=t;
if(/^drucke\(/.test(l))return"__out.push("+tEx(l.slice(7,-1))+")";let m;
if((m=l.match(/^fÃ¼r\s+([\wÃ¤Ã¶Ã¼Ã„Ã–ÃœÃŸ]+)\s+in\s+(.+):$/)))return"for(let "+m[1]+" of "+tEx(m[2])+"){";
if((m=l.match(/^solange\s+(.+):$/)))return"while("+tEx(m[1])+"){";
if((m=l.match(/^wenn\s+(.+):$/)))return"if("+tEx(m[1])+"){";
if((m=l.match(/^sonst_wenn\s+(.+):$/)))return"} else if("+tEx(m[1])+"){";
if(l==="sonst:")return"} else {";
if((m=l.match(/^funktion\s+([\wÃ¤Ã¶Ã¼Ã„Ã–ÃœÃŸ]+)\((.*)\):$/)))
return"function "+m[1]+"("+m[2].replace(/selbst,?\s*/,"")+"){";
if((m=l.match(/^klasse\s+([\wÃ¤Ã¶Ã¼Ã„Ã–ÃœÃŸ]+)\s*(\(.*\))?\s*:$/)))
return"class "+m[1]+(m[2]?" extends "+m[2].slice(1,-1):"")+"{";
if((m=l.match(/^zurÃ¼ckgeben\s+(.+)$/)))return"return "+tEx(m[1]);
if(l==="versuche:")return"try{";if(/^ausnahme/.test(l))return"}catch(__e){";
if(l==="abbrechen")return"break";if(l==="weiter")return"continue";
if(l==="Ã¼bergeben")return"/* pass */";if(l==="schlieÃŸlich:")return"}finally{";
return tEx(l)}
function tEx(e){return e.replace(/\bwahr\b/g,"true").replace(/\bfalsch\b/g,"false")
.replace(/\bnichts\b/g,"null").replace(/\bund\b/g,"&&").replace(/\boder\b/g,"||")
.replace(/\bnicht\s+/g,"!").replace(/\.anhÃ¤ngen\(/g,".push(")
.replace(/\.herausholen\(/g,".pop(").replace(/\bliste\(\)/g,"[]")
.replace(/\.ersetzen\(/g,".replace(").replace(/\.teilen\(/g,".split(")
.replace(/\.sortieren\(\)/g,".sort()").replace(/\.umkehren\(\)/g,".reverse()")
.replace(/\.einfÃ¼gen\(/g,".__einfÃ¼gen(").replace(/\.entfernen\(/g,".__entfernen(")
.replace(/\.groÃŸbuchstaben\(\)/g,".toUpperCase()").replace(/\.kleinbuchstaben\(\)/g,".toLowerCase()")
.replace(/\.streifen\(\)/g,".trim()").replace(/\.finden\(/g,".indexOf(")
.replace(/\.verbinden\(/g,".join(")
.replace(/\.beginnt_mit\(/g,".startsWith(").replace(/\.endet_mit\(/g,".endsWith(")}
function tErr(m){return m?m.replace(/is not defined/g,"ist nicht definiert")
.replace(/is not a function/g,"ist keine Funktion")
.replace(/Cannot read properties of/g,"Kann Eigenschaft nicht lesen von")
.replace(/undefined/g,"undefiniert").replace(/null/g,"nichts")
.replace(/SyntaxError/g,"Syntaxfehler").replace(/TypeError/g,"Typfehler")
.replace(/RangeError/g,"Bereichsfehler").replace(/ReferenceError/g,"Referenzfehler")
.replace(/Maximum call stack/g,"Maximale Aufruftiefe"):m}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  R U N T I M E S
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const RUNTIME = `
function bereich(...a){let s=0,e,st=1;if(a.length===1)e=a[0];else if(a.length===2){s=a[0];e=a[1]}else{s=a[0];e=a[1];st=a[2]};const r=[];for(let i=s;st>0?i<e:i>e;i+=st)r.push(i);return r}
function lÃ¤nge(x){return x.length!=null?x.length:Object.keys(x).length}
function ganzzahl(x){return parseInt(x)}
function dezimal(x){return parseFloat(x)}
function zeichenkette(x){if(Array.isArray(x))return"["+x.join(", ")+"]";return String(x)}
function summe(a){return a.reduce((s,x)=>s+x,0)}
function minimum(...a){return Math.min(...(a.length===1&&Array.isArray(a[0])?a[0]:a))}
function maximum(...a){return Math.max(...(a.length===1&&Array.isArray(a[0])?a[0]:a))}
function abs_wert(x){return Math.abs(x)}
function runden(x,d){return d!==undefined?+x.toFixed(d):Math.round(x)}
function zufall(a,b){return Math.floor(Math.random()*(b-a+1))+a}
function zufall_dezimal(){return Math.random()}
function sinus(x){return Math.sin(x)}
function kosinus(x){return Math.cos(x)}
function wurzel(x){return Math.sqrt(x)}
function potenz(x,n){return Math.pow(x,n)}
function sortiert(a,opts){const r=[...a];r.sort((x,y)=>x>y?1:x<y?-1:0);return r;}
function liste(x){if(x===undefined)return[];if(typeof x==="string")return x.split("");if(Array.isArray(x))return[...x];return Array.from(x);}
function wÃ¶rterbuch(pairs){if(!pairs)return{};const d={};for(const p of pairs)d[p[0]]=p[1];return d;}
function typ(x){if(Array.isArray(x))return"liste";if(x===null)return"nichts";return typeof x;}
function formatieren(s,...args){let i=0;return s.replace(/{}/g,()=>args[i++]!==undefined?String(args[i-1]):"{}")}
const PI=Math.PI;
function zeichne_kreis(x,y,r,c){__d.push({t:"c",x,y,r,c:c||"#fff"})}
function zeichne_linie(x1,y1,x2,y2,c,w){__d.push({t:"l",x1,y1,x2,y2,c:c||"#fff",w:w||2})}
function zeichne_rechteck(x,y,w,h,c){__d.push({t:"r",x,y,w,h,c:c||"#fff"})}
function zeichne_text(x,y,txt,c,s){__d.push({t:"tx",x,y,txt:String(txt),c:c||"#fff",s:s||16})}
function fÃ¼lle(c){__d.push({t:"f",c})}
Array.prototype.__einfÃ¼gen=function(pos,item){this.splice(pos,0,item)};
Array.prototype.__entfernen=function(item){const i=this.indexOf(item);if(i>-1)this.splice(i,1)};
`;

const TURTLE_RT = `
const __turtle={x:200,y:200,a:-90,c:"#f43f5e",w:2,pen:true,vis:true};
const schildkrÃ¶te={
  vorwÃ¤rts(d){const r=__turtle.a*Math.PI/180;const nx=__turtle.x+d*Math.cos(r);const ny=__turtle.y+d*Math.sin(r);
    if(__turtle.pen)__d.push({t:"l",x1:__turtle.x,y1:__turtle.y,x2:nx,y2:ny,c:__turtle.c,w:__turtle.w});
    __turtle.x=nx;__turtle.y=ny},
  rÃ¼ckwÃ¤rts(d){schildkrÃ¶te.vorwÃ¤rts(-d)},
  links(w){__turtle.a-=w},rechts(w){__turtle.a+=w},
  farbe(f){__turtle.c=f},breite(b){__turtle.w=b},
  stift_hoch(){__turtle.pen=false},stift_runter(){__turtle.pen=true},
  gehe_zu(x,y){if(__turtle.pen)__d.push({t:"l",x1:__turtle.x,y1:__turtle.y,x2:x,y2:y,c:__turtle.c,w:__turtle.w});__turtle.x=x;__turtle.y=y},
  kreis(r){__d.push({t:"c",x:__turtle.x,y:__turtle.y,r,c:__turtle.c})},
  verstecken(){__turtle.vis=false},zeigen(){__turtle.vis=true},
  position(){return[__turtle.x,__turtle.y]}
};`;

const SOUND_RT = `
function spiele_ton(freq,dauer,typ){
  if(typeof __audioCtx==='undefined')return;
  try{const o=__audioCtx.createOscillator();const g=__audioCtx.createGain();
  o.type=typ||'sine';o.frequency.value=freq;g.gain.value=0.15;
  o.connect(g);g.connect(__audioCtx.destination);o.start();
  g.gain.exponentialRampToValueAtTime(0.001,__audioCtx.currentTime+(dauer||0.3));
  o.stop(__audioCtx.currentTime+(dauer||0.3));}catch(e){}}
const NOTEN={C3:131,D3:147,E3:165,F3:175,G3:196,A3:220,B3:247,
  C4:262,D4:294,E4:330,F4:349,G4:392,A4:440,B4:494,C5:523,D5:587,E5:659,F5:698,G5:784,A5:880,B5:988};
function spiele_note(note,dauer){spiele_ton(NOTEN[note]||440,dauer)}`;

const PHYSICS_RT = `
const __kÃ¶rper_liste=[];let __schwerkraft_y=0.3,__schwerkraft_x=0;
function schwerkraft(sy,sx){__schwerkraft_y=sy;if(sx!==undefined)__schwerkraft_x=sx;}
function kÃ¶rper(x,y,b,h,opt){
  const k={x,y,b:b||20,h:h||20,vx:0,vy:0,fest:false,farbe:"#f43f5e",rÃ¼ckprall:0.7,reibung:0.99,id:__kÃ¶rper_liste.length};
  if(opt){if(opt.fest!==undefined)k.fest=opt.fest;if(opt.farbe)k.farbe=opt.farbe;
    if(opt.rÃ¼ckprall!==undefined)k.rÃ¼ckprall=opt.rÃ¼ckprall;if(opt.vx!==undefined)k.vx=opt.vx;if(opt.vy!==undefined)k.vy=opt.vy;}
  __kÃ¶rper_liste.push(k);return k;}
function kraft(k,fx,fy){if(!k.fest){k.vx+=fx;k.vy+=fy;}}
function physik_schritt(){
  for(const k of __kÃ¶rper_liste){if(k.fest)continue;k.vx+=__schwerkraft_x;k.vy+=__schwerkraft_y;k.vx*=k.reibung;k.vy*=k.reibung;
    k.x+=k.vx;k.y+=k.vy;
    if(k.x<0){k.x=0;k.vx*=-k.rÃ¼ckprall;}if(k.x+k.b>400){k.x=400-k.b;k.vx*=-k.rÃ¼ckprall;}
    if(k.y+k.h>400){k.y=400-k.h;k.vy*=-k.rÃ¼ckprall;}if(k.y<0){k.y=0;k.vy*=-k.rÃ¼ckprall;}}
  for(let i=0;i<__kÃ¶rper_liste.length;i++){for(let j=i+1;j<__kÃ¶rper_liste.length;j++){
    const a=__kÃ¶rper_liste[i],b=__kÃ¶rper_liste[j];
    if(a.x<b.x+b.b&&a.x+a.b>b.x&&a.y<b.y+b.h&&a.y+a.h>b.y){
      if(a.fest&&!b.fest){b.vy*=-b.rÃ¼ckprall;b.y=a.y-b.h;}
      else if(!a.fest&&b.fest){a.vy*=-a.rÃ¼ckprall;a.y=b.y-a.h;}
      else if(!a.fest&&!b.fest){const t=a.vx;a.vx=b.vx*0.9;b.vx=t*0.9;const t2=a.vy;a.vy=b.vy*0.9;b.vy=t2*0.9;a.x-=1;b.x+=1;}}}}}
function kollision(a,b){return a.x<b.x+b.b&&a.x+a.b>b.x&&a.y<b.y+b.h&&a.y+a.h>b.y;}
function kÃ¶rper_zeichnen(k){__d.push({t:"r",x:k.x,y:k.y,w:k.b,h:k.h,c:k.farbe});}
function alle_kÃ¶rper_zeichnen(){for(const k of __kÃ¶rper_liste)kÃ¶rper_zeichnen(k);}`;

const PARTICLE_RT = `
const __partikel=[];
function partikel_erzeugen(x,y,opt){const n=opt?.anzahl||20,sp=opt?.geschwindigkeit||3,f=opt?.farbe||"#facc15",l=opt?.leben||60,g=opt?.grÃ¶ÃŸe||3;
  for(let i=0;i<n;i++){const a=Math.random()*Math.PI*2;const v=Math.random()*sp+sp*0.2;
    __partikel.push({x,y,vx:Math.cos(a)*v,vy:Math.sin(a)*v,leben:l,maxL:l,farbe:f,grÃ¶ÃŸe:g+Math.random()*2});}}
function partikel_explosion(x,y,farbe,anzahl){partikel_erzeugen(x,y,{farbe:farbe||"#fb923c",anzahl:anzahl||40,geschwindigkeit:5,leben:45});}
function partikel_regen(y,farbe,anzahl){for(let i=0;i<(anzahl||5);i++){
  __partikel.push({x:Math.random()*400,y:y||0,vx:(Math.random()-0.5)*0.5,vy:Math.random()*2+1,leben:120,maxL:120,farbe:farbe||"#38bdf8",grÃ¶ÃŸe:2+Math.random()*2});}}
function partikel_aktualisieren(){for(let i=__partikel.length-1;i>=0;i--){
  const p=__partikel[i];p.x+=p.vx;p.y+=p.vy;p.vy+=0.04;p.leben--;
  if(p.leben<=0)__partikel.splice(i,1);
  else{const a=p.leben/p.maxL;__d.push({t:"c",x:p.x,y:p.y,r:p.grÃ¶ÃŸe*a,c:p.farbe});}}}
function partikel_anzahl(){return __partikel.length;}`;

const GAME_RT = `
function taste(t){return __keys[t.toLowerCase()]||__keys[t]||false;}
function punkte_anzeigen(x,y,p,opt){__d.push({t:"tx",x,y,txt:String(p),c:opt?.farbe||"#facc15",s:opt?.grÃ¶ÃŸe||20});}
function spielobjekt(x,y,b,h,farbe){return{x,y,b:b||20,h:h||20,farbe:farbe||"#fff",vx:0,vy:0};}
function objekt_zeichnen(o){__d.push({t:"r",x:o.x,y:o.y,w:o.b,h:o.h,c:o.farbe});}
function objekt_kreis(o,r){__d.push({t:"c",x:o.x,y:o.y,r:r||o.b/2,c:o.farbe});}
function objekte_kollidieren(a,b){return a.x<b.x+(b.b||0)&&a.x+(a.b||0)>b.x&&a.y<b.y+(b.h||0)&&a.y+(a.h||0)>b.y;}
function abstand(a,b){return Math.sqrt((a.x-b.x)**2+(a.y-b.y)**2);}
function bewege(o,dx,dy){o.x+=dx;o.y+=dy;}
function begrenze(o,minX,minY,maxX,maxY){if(o.x<minX)o.x=minX;if(o.y<minY)o.y=minY;if(o.x+o.b>maxX)o.x=maxX-o.b;if(o.y+o.h>maxY)o.y=maxY-o.h;}`;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ğŸ–ï¸ BODY TRACKING RUNTIME â€” Webcam-basierte Bewegungserkennung
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const CAMERA_RT = `
let kamera_x=200,kamera_y=200,kamera_bewegung=0,kamera_aktiv=false;
function kamera_starten(){kamera_aktiv=true;if(__cam)__cam.start();}
function kamera_stoppen(){kamera_aktiv=false;if(__cam)__cam.stop();}
`;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ğŸ§  KI TRAINING RUNTIME â€” Trainierbare KI auf Deutsch
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const KI_RT = `
function ki_erstellen(){return{daten:[],klassen:new Set()};}
function ki_lernen(ki,klasse,merkmale){
  if(!ki||!klasse||!merkmale)return;
  ki.daten.push({klasse,merkmale:Array.isArray(merkmale)?merkmale:[merkmale]});
  ki.klassen.add(klasse);
  return ki.daten.length;
}
function ki_vorhersagen(ki,merkmale){
  if(!ki||!ki.daten.length)return"unbekannt";
  const m=Array.isArray(merkmale)?merkmale:[merkmale];
  const dists=ki.daten.map(d=>{
    let s=0;for(let i=0;i<Math.min(m.length,d.merkmale.length);i++)s+=(m[i]-d.merkmale[i])**2;
    return{klasse:d.klasse,dist:Math.sqrt(s)};
  });
  dists.sort((a,b)=>a.dist-b.dist);
  const k=Math.min(3,dists.length);
  const votes={};
  for(let i=0;i<k;i++){const c=dists[i].klasse;votes[c]=(votes[c]||0)+1;}
  let best="",bestN=0;
  for(const[c,n]of Object.entries(votes)){if(n>bestN){bestN=n;best=c;}}
  return best;
}
function ki_genauigkeit(ki){
  if(!ki||ki.daten.length<4)return 0;
  let korrekt=0;
  for(let i=0;i<ki.daten.length;i++){
    const test=ki.daten[i];
    const rest={daten:ki.daten.filter((_,j)=>j!==i),klassen:ki.klassen};
    if(ki_vorhersagen(rest,test.merkmale)===test.klasse)korrekt++;
  }
  return runden(korrekt/ki.daten.length*100,1);
}
function ki_daten_anzahl(ki){return ki?ki.daten.length:0;}
function ki_klassen(ki){return ki?[...ki.klassen]:[];}
`;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ğŸ§Š 3D RUNTIME â€” Three.js mit deutscher API
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const THREE_RT = `
let __3d_mode=false;
let __3d_cam={x:0,y:2,z:6,lx:0,ly:0,lz:0};
let __3d_rot={x:0,y:0,z:0};
let __3d_bg="#0a0a14";
function szene_3d(hintergrund){__3d_mode=true;if(hintergrund)__3d_bg=hintergrund;__d3.length=0;}
function wÃ¼rfel_3d(x,y,z,grÃ¶ÃŸe,farbe){__d3.push({t:"box",x:x||0,y:y||0,z:z||0,s:grÃ¶ÃŸe||1,c:farbe||"#f43f5e"});}
function kugel_3d(x,y,z,radius,farbe){__d3.push({t:"sphere",x:x||0,y:y||0,z:z||0,r:radius||0.5,c:farbe||"#38bdf8"});}
function zylinder_3d(x,y,z,radius,hÃ¶he,farbe){__d3.push({t:"cyl",x:x||0,y:y||0,z:z||0,r:radius||0.5,h:hÃ¶he||1,c:farbe||"#2dd4bf"});}
function ebene_3d(x,y,z,b,h,farbe){__d3.push({t:"plane",x:x||0,y:y||0,z:z||0,w:b||10,h:h||10,c:farbe||"#1a1a2e"});}
function licht_3d(x,y,z,farbe,stÃ¤rke){__d3.push({t:"light",x:x||5,y:y||5,z:z||5,c:farbe||"#ffffff",i:stÃ¤rke||1});}
function kamera_3d(x,y,z){__3d_cam.x=x;__3d_cam.y=y;__3d_cam.z=z;}
function blickpunkt_3d(x,y,z){__3d_cam.lx=x;__3d_cam.ly=y;__3d_cam.lz=z;}
function drehen_3d(rx,ry,rz){__3d_rot.x+=rx||0;__3d_rot.y+=ry||0;__3d_rot.z+=rz||0;}
function text_3d(x,y,z,txt,farbe,grÃ¶ÃŸe){__d3.push({t:"txt3d",x:x||0,y:y||0,z:z||0,txt:String(txt),c:farbe||"#fff",s:grÃ¶ÃŸe||1});}
`;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ğŸ‘¥ MULTIPLAYER RUNTIME â€” Shared state via storage API
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const MULTI_RT = `
let __mp_id="spieler_"+Math.floor(Math.random()*99999);
let __mp_daten={};
let __mp_alle={};
function mehrspieler_name(name){__mp_id=name||__mp_id;}
function mehrspieler_senden(schlÃ¼ssel,wert){
  __mp_daten[schlÃ¼ssel]=wert;
  if(__storage){try{__storage.set("mp:"+__mp_id,JSON.stringify({id:__mp_id,t:Date.now(),d:__mp_daten}),true)}catch(e){}}
}
function mehrspieler_lesen(spieler,schlÃ¼ssel){
  if(__mp_alle[spieler]&&__mp_alle[spieler].d)return __mp_alle[spieler].d[schlÃ¼ssel];
  return null;
}
function mehrspieler_alle(){return Object.keys(__mp_alle).filter(k=>k!==__mp_id);}
function mehrspieler_anzahl(){return Object.keys(__mp_alle).length;}
function mein_name(){return __mp_id;}
`;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ğŸŒ SHADER RUNTIME â€” WebGL Fragment-Shader mit deutscher API
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const SHADER_RT = `
let __shader_mode=false;
let __shader_code="";
let __shader_uniforms={};
function shader(code){__shader_mode=true;__shader_code=code;}
function shader_wert(name,wert){__shader_uniforms[name]=wert;}
`;

// â”€â”€ HIGHLIGHTING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const KW_RE="wenn|sonst_wenn|sonst|solange|fÃ¼r|abbrechen|weiter|Ã¼bergeben|funktion|zurÃ¼ckgeben|klasse|selbst|wahr|falsch|und|oder|nicht|nichts|versuche|ausnahme|schlieÃŸlich|in";
const FN_RE="drucke|bereich|lÃ¤nge|zeichenkette|ganzzahl|dezimal|liste|sortiert|minimum|maximum|summe|zufall|zufall_dezimal|sinus|kosinus|wurzel|potenz|abs_wert|runden|typ|formatieren|wÃ¶rterbuch|zeichne_kreis|zeichne_linie|zeichne_rechteck|zeichne_text|fÃ¼lle|spiele_ton|spiele_note|schildkrÃ¶te|schwerkraft|kÃ¶rper|kraft|physik_schritt|kollision|kÃ¶rper_zeichnen|alle_kÃ¶rper_zeichnen|partikel_erzeugen|partikel_explosion|partikel_regen|partikel_aktualisieren|partikel_anzahl|taste|spielobjekt|objekt_zeichnen|objekt_kreis|objekte_kollidieren|abstand|bewege|begrenze|punkte_anzeigen|kamera_starten|kamera_stoppen|ki_erstellen|ki_lernen|ki_vorhersagen|ki_genauigkeit|ki_daten_anzahl|ki_klassen|szene_3d|wÃ¼rfel_3d|kugel_3d|zylinder_3d|ebene_3d|licht_3d|kamera_3d|blickpunkt_3d|drehen_3d|text_3d|mehrspieler_name|mehrspieler_senden|mehrspieler_lesen|mehrspieler_alle|mehrspieler_anzahl|mein_name|shader|shader_wert";
function hlDE(code){return code.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")
.replace(/(#.*?)$/gm,'<em style="color:#525280">$1</em>')
.replace(/("(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*')/g,'<b style="color:#2dd4bf">$1</b>')
.replace(/\b(\d+\.?\d*)\b/g,'<b style="color:#facc15">$1</b>')
.replace(new RegExp(`(?<![a-zA-ZÃ¤Ã¶Ã¼Ã„Ã–ÃœÃŸ_])(${KW_RE})(?![a-zA-ZÃ¤Ã¶Ã¼Ã„Ã–ÃœÃŸ_])`,"g"),'<b style="color:#f43f5e">$1</b>')
.replace(new RegExp(`(?<![a-zA-ZÃ¤Ã¶Ã¼Ã„Ã–ÃœÃŸ_.])(${FN_RE})(?=[.(])`,"g"),'<b style="color:#38bdf8">$1</b>')}

// â”€â”€ AI PROMPTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const AI_SYS=`Du bist Black Swan â€” die deutsche Programmiersprache. Generiere NUR Code, KEIN Markdown/Backticks.
Keywords: wenn, sonst, sonst_wenn, fÃ¼r, solange, funktion, zurÃ¼ckgeben, wahr, falsch, und, oder, nicht
Funktionen: drucke(), bereich(), lÃ¤nge(), zeichenkette(), ganzzahl(), zufall(min,max), sinus(), kosinus(), PI
2D Canvas: zeichne_kreis(x,y,r,farbe), zeichne_linie(x1,y1,x2,y2,farbe,breite), zeichne_rechteck(x,y,b,h,farbe), zeichne_text(x,y,text,farbe,grÃ¶ÃŸe), fÃ¼lle(farbe)
SchildkrÃ¶te: schildkrÃ¶te.vorwÃ¤rts(d), .links(w), .rechts(w), .farbe(f), .breite(b), .kreis(r)
Physik: schwerkraft(stÃ¤rke), kÃ¶rper(x,y,b,h,{fest,farbe,rÃ¼ckprall}), kraft(k,fx,fy), physik_schritt(), alle_kÃ¶rper_zeichnen()
Partikel: partikel_explosion(x,y,farbe,anzahl), partikel_regen(y,farbe), partikel_aktualisieren()
Game: taste("links"/"rechts"/"hoch"/"runter"/"leertaste"), spielobjekt(x,y,b,h,farbe), objekt_zeichnen(o), objekte_kollidieren(a,b), bewege(o,dx,dy), begrenze(o,0,0,400,400)
3D: szene_3d(), wÃ¼rfel_3d(x,y,z,grÃ¶ÃŸe,farbe), kugel_3d(x,y,z,radius,farbe), zylinder_3d(x,y,z,r,h,farbe), ebene_3d(x,y,z,b,h,farbe), licht_3d(x,y,z), kamera_3d(x,y,z), drehen_3d(rx,ry,rz)
Kamera: kamera_starten(), kamera_x, kamera_y, kamera_bewegung
KI: ki=ki_erstellen(), ki_lernen(ki,klasse,merkmale), ki_vorhersagen(ki,merkmale), ki_genauigkeit(ki)
Mehrspieler: mehrspieler_name(name), mehrspieler_senden(schlÃ¼ssel,wert), mehrspieler_lesen(spieler,schlÃ¼ssel), mehrspieler_alle(), mehrspieler_anzahl(), mein_name()
Shader: shader(glsl_code), shader_wert(name,wert) â€” GLSL Fragment-Shader, uniforms: zeit, auflÃ¶sung, maus
Animation: funktion zeichne(): fÃ¼r 60fps. Nutze rahmen, maus_x, maus_y, maus_gedrÃ¼ckt
Sound: spiele_ton(freq,dauer), spiele_note("C4",dauer)
Alles auf Deutsch.`;

const TUTOR_SYS=`Du bist der Black Swan KI-Tutor. ErklÃ¤re Code auf Deutsch in einfacher Sprache. Max 4-5 SÃ¤tze. Sei ermutigend.
Black Swan ist eine deutsche Programmiersprache die zu Python transpiliert. fÃ¼r=for, wenn=if, funktion=def, drucke=print.
Neue Features: 3D (szene_3d, wÃ¼rfel_3d, kugel_3d), Physik (schwerkraft, kÃ¶rper), Partikel, Game Engine (taste), Kamera (kamera_starten), KI Training (ki_erstellen, ki_lernen), Mehrspieler (mehrspieler_senden/lesen), Shader (shader(glsl)).`;

// â”€â”€ SPEECH TO CODE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function speechToCode(raw){let t=raw.trim();
const kws=["drucke","wenn","sonst","solange","fÃ¼r","funktion","zurÃ¼ckgeben","wahr","falsch",
"und","oder","nicht","nichts","bereich","lÃ¤nge","zeichenkette","ganzzahl","liste",
"zeichne_kreis","zeichne_linie","zeichne_rechteck","fÃ¼lle","sinus","kosinus","zufall",
"schildkrÃ¶te","spiele_ton","kÃ¶rper","schwerkraft","partikel_explosion","taste","spielobjekt",
"szene_3d","wÃ¼rfel_3d","kugel_3d","kamera_starten","ki_erstellen","ki_lernen",
"mehrspieler_senden","mehrspieler_lesen","mehrspieler_name","shader","shader_wert","in"];
for(const k of kws)t=t.replace(new RegExp("\\b"+k+"\\b","gi"),k);
const nums=[["null","0"],["eins","1"],["zwei","2"],["drei","3"],["vier","4"],["fÃ¼nf","5"],
["sechs","6"],["sieben","7"],["acht","8"],["neun","9"],["zehn","10"]];
for(const[w,d]of nums)t=t.replace(new RegExp(`\\b${w}\\b`,"gi"),d);
t=t.replace(/\bgleich gleich\b/gi,"==").replace(/\bgrÃ¶ÃŸer\b/gi,">").replace(/\bkleiner\b/gi,"<")
.replace(/\bgleich\b/gi,"=").replace(/\bplus\b/gi,"+").replace(/\bminus\b/gi,"-")
.replace(/\bklammer auf\b/gi,"(").replace(/\bklammer zu\b/gi,")").replace(/\bkomma\b/gi,",");
t=t.replace(/^drucke\s+(?!\()(.+?)$/gm,(_,a)=>/[+\-*/=<>]/.test(a)?`drucke(${a})`:`drucke("${a}")`);
if(/^(fÃ¼r\s+\w+\s+in|wenn\s|solange\s|funktion\s)/.test(t)&&!t.endsWith(":"))t+=":";
return t.replace(/\s+/g," ").trim()}

// â”€â”€ GALLERY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const GALLERY=[
{t:"ğŸ§Š 3D Welt",d:"Three.js 3D Szene",c:`# 3D-Szene mit deutscher API!
szene_3d("#0a0a1a")
licht_3d(5, 8, 5, "#ffffff", 1)
licht_3d(-3, 4, -2, "#38bdf8", 0.5)

# Boden
ebene_3d(0, -1, 0, 12, 12, "#1a1a2e")

# GebÃ¤ude
fÃ¼r i in bereich(0, 5):
    fÃ¼r j in bereich(0, 5):
        hÃ¶he = 0.3 + zufall_dezimal() * 2
        x = (i - 2) * 2.2
        z = (j - 2) * 2.2
        farbe = "hsl(" + zeichenkette(i * 50 + j * 30) + ",60%,45%)"
        wÃ¼rfel_3d(x, hÃ¶he / 2 - 1, z, hÃ¶he, farbe)

# Kugel oben drauf
kugel_3d(0, 2, 0, 0.6, "#f43f5e")

kamera_3d(6, 5, 6)
blickpunkt_3d(0, 0, 0)

funktion zeichne():
    drehen_3d(0, 0.008, 0)`},

{t:"ğŸ–ï¸ Kamera",d:"KÃ¶rpersteuerung",c:`# Webcam-Bewegungssteuerung!
# Erlaube Kamerazugriff wenn gefragt
kamera_starten()

funktion zeichne():
    fÃ¼lle("#08080f")
    # Bewegungsanzeige
    grÃ¶ÃŸe = 10 + kamera_bewegung * 2
    farbe = "hsl(" + zeichenkette(kamera_bewegung * 3) + ",80%,55%)"
    zeichne_kreis(kamera_x, kamera_y, grÃ¶ÃŸe, farbe)
    # Spur
    zeichne_kreis(kamera_x, kamera_y, grÃ¶ÃŸe + 15, farbe + "30")
    zeichne_kreis(kamera_x, kamera_y, grÃ¶ÃŸe + 30, farbe + "15")
    # Info
    zeichne_text(10, 20, "ğŸ–ï¸ Bewege dich vor der Kamera!", "#666", 13)
    zeichne_text(10, 40, "Bewegung: " + zeichenkette(ganzzahl(kamera_bewegung)), "#525280", 11)
    zeichne_text(10, 56, "X: " + zeichenkette(ganzzahl(kamera_x)) + " Y: " + zeichenkette(ganzzahl(kamera_y)), "#525280", 11)`},

{t:"ğŸ§  KI-Train",d:"KI Trainieren",c:`# Trainiere deine eigene KI!
ki = ki_erstellen()

# Trainings-Daten: Tiere nach [GrÃ¶ÃŸe, Geschwindigkeit, Gewicht]
ki_lernen(ki, "Maus", [0.1, 0.3, 0.02])
ki_lernen(ki, "Maus", [0.08, 0.25, 0.03])
ki_lernen(ki, "Maus", [0.12, 0.35, 0.02])
ki_lernen(ki, "Katze", [0.4, 0.5, 4.0])
ki_lernen(ki, "Katze", [0.35, 0.45, 3.5])
ki_lernen(ki, "Katze", [0.45, 0.55, 5.0])
ki_lernen(ki, "Hund", [0.6, 0.7, 25.0])
ki_lernen(ki, "Hund", [0.55, 0.8, 20.0])
ki_lernen(ki, "Hund", [0.7, 0.65, 30.0])
ki_lernen(ki, "Pferd", [2.0, 0.9, 500.0])
ki_lernen(ki, "Pferd", [1.8, 0.85, 450.0])
ki_lernen(ki, "Pferd", [2.2, 0.95, 550.0])

# Testen
drucke("ğŸ§  KI-Modell trainiert!")
drucke("Daten: " + zeichenkette(ki_daten_anzahl(ki)) + " EintrÃ¤ge")
drucke("Klassen: " + zeichenkette(ki_klassen(ki)))
drucke("Genauigkeit: " + zeichenkette(ki_genauigkeit(ki)) + "%")
drucke("")
drucke("--- Vorhersagen ---")
drucke("Klein+Langsam â†’ " + ki_vorhersagen(ki, [0.1, 0.2, 0.03]))
drucke("Mittel+Schnell â†’ " + ki_vorhersagen(ki, [0.5, 0.6, 15.0]))
drucke("GroÃŸ+Schnell â†’ " + ki_vorhersagen(ki, [1.9, 0.88, 480.0]))

# Visualisierung
klassen = ki_klassen(ki)
farben = ["#f43f5e", "#38bdf8", "#facc15", "#2dd4bf"]
fÃ¼r k in bereich(0, lÃ¤nge(klassen)):
    zeichne_rechteck(20, 240 + k * 35, 360, 28, farben[k] + "20")
    zeichne_text(30, 260 + k * 35, klassen[k], farben[k], 16)
zeichne_text(100, 220, "ğŸ§  Trainierte Klassen", "#666", 14)`},

{t:"âš›ï¸ Physik",d:"Physik-Engine",c:`# Physik-Engine: BÃ¤lle mit Schwerkraft
schwerkraft(0.4)
kÃ¶rper(0, 380, 400, 20, {"fest": wahr, "farbe": "#1a1a2e"})
kÃ¶rper(100, 300, 150, 10, {"fest": wahr, "farbe": "#38bdf8"})
fÃ¼r i in bereich(0, 8):
    x = 50 + i * 45
    farbe = "hsl(" + zeichenkette(i * 40) + ",75%,55%)"
    kÃ¶rper(x, 20 + i * 15, 18, 18, {"farbe": farbe, "rÃ¼ckprall": 0.6 + i * 0.04})
funktion zeichne():
    fÃ¼lle("#08080f")
    physik_schritt()
    alle_kÃ¶rper_zeichnen()
    zeichne_text(10, 18, "âš›ï¸ Physik-Engine", "#525280", 13)`},

{t:"ğŸ® Pong",d:"Tastatur-Spiel",c:`# PONG â€” Pfeiltasten â†‘â†“
schlÃ¤ger = spielobjekt(20, 170, 12, 60, "#f43f5e")
ki_s = spielobjekt(368, 170, 12, 60, "#38bdf8")
ball = spielobjekt(195, 195, 10, 10, "#facc15")
ball.vx = 3
ball.vy = 2
p_l = 0
p_r = 0
funktion zeichne():
    fÃ¼lle("#08080f")
    wenn taste("hoch"):
        bewege(schlÃ¤ger, 0, -5)
    wenn taste("runter"):
        bewege(schlÃ¤ger, 0, 5)
    begrenze(schlÃ¤ger, 0, 0, 400, 400)
    wenn ki_s.y + 30 < ball.y:
        bewege(ki_s, 0, 3)
    wenn ki_s.y + 30 > ball.y:
        bewege(ki_s, 0, -3)
    ball.x = ball.x + ball.vx
    ball.y = ball.y + ball.vy
    wenn ball.y < 0 oder ball.y > 390:
        ball.vy = ball.vy * -1
    wenn objekte_kollidieren(ball, schlÃ¤ger):
        ball.vx = abs_wert(ball.vx) * 1.05
        spiele_ton(440, 0.05)
        partikel_erzeugen(ball.x, ball.y, {"farbe": "#f43f5e", "anzahl": 8})
    wenn objekte_kollidieren(ball, ki_s):
        ball.vx = -abs_wert(ball.vx) * 1.05
        spiele_ton(330, 0.05)
    wenn ball.x < 0:
        p_r = p_r + 1
        ball.x = 195
        ball.y = 195
        ball.vx = 3
    wenn ball.x > 400:
        p_l = p_l + 1
        ball.x = 195
        ball.y = 195
        ball.vx = -3
    partikel_aktualisieren()
    fÃ¼r i in bereich(0, 20):
        zeichne_rechteck(198, i * 22, 4, 12, "#1a1a2e")
    objekt_zeichnen(schlÃ¤ger)
    objekt_zeichnen(ki_s)
    objekt_zeichnen(ball)
    punkte_anzeigen(140, 35, p_l, {"farbe": "#f43f5e"})
    punkte_anzeigen(240, 35, p_r, {"farbe": "#38bdf8"})`},

{t:"ğŸ­ Partikel",d:"Klick-Effekte",c:`# Klicke fÃ¼r Partikel-Explosionen!
funktion zeichne():
    fÃ¼lle("#08080f")
    partikel_regen(0, "#38bdf855", 2)
    wenn maus_gedrÃ¼ckt:
        farbe = "hsl(" + zeichenkette(rahmen * 5) + ",80%,60%)"
        partikel_explosion(maus_x, maus_y, farbe, 30)
        spiele_ton(200 + maus_y, 0.1)
    partikel_aktualisieren()
    zeichne_text(100, 390, "Klicke irgendwo!", "#333", 12)`},

{t:"ğŸ¢ Stern",d:"SchildkrÃ¶te",c:`# SchildkrÃ¶te zeichnet einen Stern
schildkrÃ¶te.farbe("#facc15")
schildkrÃ¶te.breite(3)
fÃ¼r i in bereich(0, 5):
    schildkrÃ¶te.vorwÃ¤rts(150)
    schildkrÃ¶te.rechts(144)`},

{t:"ğŸŒ€ Spirale",d:"Regenbogen",c:`schildkrÃ¶te.breite(2)
fÃ¼r i in bereich(0, 150):
    farbe = "hsl(" + zeichenkette(i * 2.4) + ",80%,60%)"
    schildkrÃ¶te.farbe(farbe)
    schildkrÃ¶te.vorwÃ¤rts(i * 1.5)
    schildkrÃ¶te.rechts(91)`},

{t:"ğŸŒ³ Fraktal",d:"Rekursiver Baum",c:`# Fraktalbaum â€” rekursive Verzweigung
funktion ast(tiefe, lÃ¤nge, winkel):
    wenn tiefe == 0:
        zurÃ¼ckgeben nichts
    # Ã„ste werden dÃ¼nner und farbiger
    schildkrÃ¶te.breite(tiefe * 0.8)
    grÃ¼n = ganzzahl(100 + (8 - tiefe) * 20)
    schildkrÃ¶te.farbe("rgb(60," + zeichenkette(grÃ¼n) + ",40)")
    wenn tiefe < 3:
        schildkrÃ¶te.farbe("#2dd4bf")
    schildkrÃ¶te.vorwÃ¤rts(lÃ¤nge)
    # Links verzweigen
    schildkrÃ¶te.links(winkel)
    ast(tiefe - 1, lÃ¤nge * 0.72, winkel)
    # Rechts verzweigen
    schildkrÃ¶te.rechts(winkel * 2)
    ast(tiefe - 1, lÃ¤nge * 0.72, winkel)
    # ZurÃ¼ck
    schildkrÃ¶te.links(winkel)
    schildkrÃ¶te.rÃ¼ckwÃ¤rts(lÃ¤nge)

# Baum zeichnen
schildkrÃ¶te.stift_hoch()
schildkrÃ¶te.gehe_zu(200, 380)
schildkrÃ¶te.stift_runter()
schildkrÃ¶te.links(90)
ast(8, 65, 28)`},

{t:"ğŸª Orbit",d:"Animation",c:`funktion zeichne():
    fÃ¼lle("#050510")
    fÃ¼r i in bereich(0, 40):
        sx = (i * 137 + rahmen * 0.2) % 400
        sy = (i * 89) % 400
        zeichne_kreis(sx, sy, 0.8, "#ffffff20")
    zeichne_kreis(200, 200, 25, "#facc15")
    fÃ¼r p in bereich(0, 6):
        abst = 55 + p * 32
        winkel = rahmen * (0.025 - p * 0.003) + p * 1.2
        x = 200 + abst * kosinus(winkel)
        y = 200 + abst * sinus(winkel)
        zeichne_kreis(x, y, 5 + p * 2, "hsl(" + zeichenkette(p * 55 + 180) + ",70%,55%)")`},

{t:"ğŸ“Š Sortier",d:"Bubblesort Live",c:`# Bubblesort â€” Schritt fÃ¼r Schritt animiert
werte = liste()
fÃ¼r i in bereich(0, 50):
    werte.anhÃ¤ngen(zufall(10, 380))

zeiger = 0
durch = 0
fertig = falsch
tausch = 0

funktion zeichne():
    fÃ¼lle("#08080f")
    wenn nicht fertig:
        # Ein Vergleichsschritt pro Frame
        wenn werte[zeiger] > werte[zeiger + 1]:
            temp = werte[zeiger]
            werte[zeiger] = werte[zeiger + 1]
            werte[zeiger + 1] = temp
            tausch = tausch + 1
        zeiger = zeiger + 1
        wenn zeiger >= lÃ¤nge(werte) - 1 - durch:
            zeiger = 0
            durch = durch + 1
            wenn durch >= lÃ¤nge(werte) - 1:
                fertig = wahr
    # Balken zeichnen
    b = 400 / lÃ¤nge(werte)
    fÃ¼r i in bereich(0, lÃ¤nge(werte)):
        farbe = "#38bdf8"
        wenn i == zeiger und nicht fertig:
            farbe = "#f43f5e"
        wenn fertig:
            farbe = "hsl(" + zeichenkette(i * 5) + ",75%,55%)"
        zeichne_rechteck(i * b, 400 - werte[i], b - 1, werte[i], farbe)
    zeichne_text(10, 18, "Bubblesort â€” Tausch: " + zeichenkette(tausch), "#e2e2f0", 12)
    wenn fertig:
        zeichne_text(130, 200, "âœ“ Sortiert!", "#2dd4bf", 18)`},

{t:"ğŸ‘¥ Multi",d:"Mehrspieler",c:`# Mehrspieler â€” Ã¶ffne dieses Artifact in 2 Tabs!
mehrspieler_name("spieler_" + zeichenkette(zufall(1, 999)))
farbe_id = zufall(0, 360)

funktion zeichne():
    fÃ¼lle("#08080f")
    # Eigene Position senden
    mehrspieler_senden("x", maus_x)
    mehrspieler_senden("y", maus_y)
    mehrspieler_senden("farbe", farbe_id)
    # Alle Spieler anzeigen
    spieler = mehrspieler_alle()
    fÃ¼r s in spieler:
        sx = mehrspieler_lesen(s, "x")
        sy = mehrspieler_lesen(s, "y")
        sf = mehrspieler_lesen(s, "farbe")
        wenn sx und sy:
            farbe = "hsl(" + zeichenkette(sf) + ",70%,55%)"
            zeichne_kreis(sx, sy, 15, farbe)
            zeichne_text(sx - 15, sy - 22, s, farbe, 9)
    # Eigenen Cursor zeichnen
    meine_farbe = "hsl(" + zeichenkette(farbe_id) + ",80%,60%)"
    zeichne_kreis(maus_x, maus_y, 18, meine_farbe)
    zeichne_kreis(maus_x, maus_y, 25, meine_farbe + "40")
    zeichne_text(maus_x - 15, maus_y - 26, mein_name(), meine_farbe, 9)
    # Info
    zeichne_text(10, 18, "ğŸ‘¥ Spieler: " + zeichenkette(mehrspieler_anzahl()), "#666", 12)
    zeichne_text(10, 36, "Ã–ffne in 2 Tabs!", "#525280", 10)`},

{t:"ğŸŒ Shader",d:"Julia-Fraktal",c:`# GPU Julia-Fraktal â€” Maus bewegt den Parameter!
shader("precision highp float; uniform float zeit; uniform vec2 auflÃ¶sung; uniform vec2 maus; void main(){ vec2 uv=(gl_FragCoord.xy-auflÃ¶sung*0.5)/auflÃ¶sung.y*2.5; vec2 c=vec2(cos(zeit*0.3)*0.7,sin(zeit*0.23)*0.7); if(maus.x>0.0)c=(maus/auflÃ¶sung-0.5)*2.5; vec2 z=uv; float i; for(i=0.0;i<128.0;i++){if(dot(z,z)>4.0)break; z=vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y)+c;} float t=i/128.0; float r=0.5+0.5*cos(3.0+t*6.28+0.0); float g=0.5+0.5*cos(3.0+t*6.28+2.1); float b=0.5+0.5*cos(3.0+t*6.28+4.2); if(i>=128.0){r=0.0;g=0.0;b=0.0;} gl_FragColor=vec4(r,g,b,1.0); }")

funktion zeichne():
    x = 0`},

{t:"ğŸ§¬ Life",d:"Conway's Game of Life",c:`# Conway's Game of Life â€” ZellulÃ¤rer Automat
grÃ¶ÃŸe = 40
zellen = liste()
nÃ¤chste = liste()

# ZufÃ¤lliges Startmuster
fÃ¼r y in bereich(0, grÃ¶ÃŸe):
    zeile = liste()
    z2 = liste()
    fÃ¼r x in bereich(0, grÃ¶ÃŸe):
        zeile.anhÃ¤ngen(zufall(0, 4) == 0)
        z2.anhÃ¤ngen(falsch)
    zellen.anhÃ¤ngen(zeile)
    nÃ¤chste.anhÃ¤ngen(z2)

funktion nachbarn(gx, gy):
    n = 0
    fÃ¼r dy in bereich(-1, 2):
        fÃ¼r dx in bereich(-1, 2):
            wenn dx == 0 und dy == 0:
                weiter
            nx = (gx + dx) % grÃ¶ÃŸe
            ny = (gy + dy) % grÃ¶ÃŸe
            wenn zellen[ny][nx]:
                n = n + 1
    zurÃ¼ckgeben n

gen = 0
funktion zeichne():
    gen = gen + 1
    # Regeln anwenden
    fÃ¼r y in bereich(0, grÃ¶ÃŸe):
        fÃ¼r x in bereich(0, grÃ¶ÃŸe):
            n = nachbarn(x, y)
            wenn zellen[y][x]:
                nÃ¤chste[y][x] = (n == 2 oder n == 3)
            sonst:
                nÃ¤chste[y][x] = (n == 3)
    # Kopieren und zeichnen
    fÃ¼r y in bereich(0, grÃ¶ÃŸe):
        fÃ¼r x in bereich(0, grÃ¶ÃŸe):
            zellen[y][x] = nÃ¤chste[y][x]
            wenn zellen[y][x]:
                zeichne_rechteck(x * 10, y * 10, 9, 9, "#2dd4bf")
    zeichne_text(10, 396, "Generation: " + zeichenkette(gen), "#525280", 10)`},
];

// â”€â”€ COLORS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const C={R:"#f43f5e",B:"#38bdf8",T:"#2dd4bf",Y:"#facc15",P:"#a78bfa",O:"#fb923c",
  BG:"#050508",S1:"#0a0a12",S2:"#0f0f1a",BD:"#1a1a2e",TX:"#e2e2f0",DM:"#525280"};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  C O M P O N E N T
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function BlackSwan() {
  const [code, setCode] = useState(GALLERY[0].c);
  const [activeG, setActiveG] = useState(0);
  const [consoleOut, setConsoleOut] = useState([]);
  const [isAnim, setIsAnim] = useState(false);
  const [is3D, setIs3D] = useState(false);
  const [isShader, setIsShader] = useState(false);
  const canvasRef = useRef(null);
  const canvas3DRef = useRef(null);
  const shaderRef = useRef(null); // WebGL shader canvas
  const consoleRef = useRef(null);
  const animRef = useRef(null);
  const mouseRef = useRef({x:200,y:200,down:false});
  const keysRef = useRef({});
  const audioRef = useRef(null);
  const threeRef = useRef(null);
  const glRef = useRef(null); // WebGL context for shaders
  const mpPollRef = useRef(null); // Multiplayer polling interval

  // Camera (webcam) tracking
  const camRef = useRef({active:false,x:200,y:200,motion:0,video:null,prevFrame:null});

  // Panels
  const [showPy, setShowPy] = useState(false);
  const [showDebug, setShowDebug] = useState(false);
  const [showTutor, setShowTutor] = useState(false);
  const [showAI, setShowAI] = useState(false);
  const [showVoice, setShowVoice] = useState(false);
  const [debugVars, setDebugVars] = useState({});
  const [camActive, setCamActive] = useState(false);

  // Voice
  const [listening, setListening] = useState(false);
  const [transcript, setTranscript] = useState("");
  const [interim, setInterim] = useState("");
  const [voiceOK, setVoiceOK] = useState(false);
  const recRef = useRef(null);
  const waveRef = useRef(null);
  const waveAnimRef = useRef(null);

  // AI / Tutor
  const [aiInput, setAiInput] = useState("");
  const [aiLoading, setAiLoading] = useState(false);
  const [tutorQ, setTutorQ] = useState("");
  const [tutorA, setTutorA] = useState("");
  const [tutorLoading, setTutorLoading] = useState(false);

  // â”€â”€ KEYBOARD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  useEffect(() => {
    const km={"arrowleft":"links","arrowright":"rechts","arrowup":"hoch","arrowdown":"runter"," ":"leertaste"};
    const down=e=>{const k=e.key.toLowerCase();keysRef.current[k]=true;if(km[k])keysRef.current[km[k]]=true;
      if(["arrowup","arrowdown","arrowleft","arrowright"," "].includes(k)&&isAnim)e.preventDefault();};
    const up=e=>{const k=e.key.toLowerCase();keysRef.current[k]=false;if(km[k])keysRef.current[km[k]]=false;};
    window.addEventListener("keydown",down);window.addEventListener("keyup",up);
    return()=>{window.removeEventListener("keydown",down);window.removeEventListener("keyup",up);};
  }, [isAnim]);

  // â”€â”€ VOICE INIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  useEffect(()=>{
    const SR=window.SpeechRecognition||window.webkitSpeechRecognition;if(!SR)return;setVoiceOK(true);
    const r=new SR();r.lang="de-DE";r.continuous=true;r.interimResults=true;
    r.onresult=ev=>{let fin="",intr="";
      for(let i=ev.resultIndex;i<ev.results.length;i++){if(ev.results[i].isFinal)fin+=ev.results[i][0].transcript;else intr+=ev.results[i][0].transcript;}
      setInterim(intr);if(fin)setTranscript(p=>p+(p?" ":"")+fin);};
    r.onerror=()=>{};r.onend=()=>setListening(false);recRef.current=r;
  },[]);

  // â”€â”€ CANVAS MOUSE + TOUCH (overlay approach for all modes) â”€â”€â”€â”€â”€â”€â”€â”€
  const mouseOverlayRef = useRef(null);
  useEffect(()=>{
    const cv=mouseOverlayRef.current;if(!cv)return;
    const rect=()=>cv.getBoundingClientRect();
    const sp=(cx,cy)=>{const r=rect();mouseRef.current.x=((cx-r.left)/r.width)*400;mouseRef.current.y=((cy-r.top)/r.height)*400;};
    const mm=e=>sp(e.clientX,e.clientY),md=()=>{mouseRef.current.down=true},mu=()=>{mouseRef.current.down=false};
    const ts=e=>{e.preventDefault();const t=e.touches[0];sp(t.clientX,t.clientY);mouseRef.current.down=true;};
    const tm=e=>{e.preventDefault();const t=e.touches[0];sp(t.clientX,t.clientY);};
    const te=e=>{e.preventDefault();mouseRef.current.down=false;};
    cv.addEventListener("mousemove",mm);cv.addEventListener("mousedown",md);window.addEventListener("mouseup",mu);
    cv.addEventListener("touchstart",ts,{passive:false});cv.addEventListener("touchmove",tm,{passive:false});cv.addEventListener("touchend",te,{passive:false});
    return()=>{cv.removeEventListener("mousemove",mm);cv.removeEventListener("mousedown",md);window.removeEventListener("mouseup",mu);
      cv.removeEventListener("touchstart",ts);cv.removeEventListener("touchmove",tm);cv.removeEventListener("touchend",te);};
  },[]);

  // â”€â”€ WEBCAM MOTION DETECTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const startCamera = useCallback(async ()=>{
    if(camRef.current.active)return;
    try{
      const stream=await navigator.mediaDevices.getUserMedia({video:{width:160,height:120,facingMode:"user"}});
      const v=document.createElement("video");v.srcObject=stream;v.play();
      camRef.current={active:true,x:200,y:200,motion:0,video:v,prevFrame:null};
      setCamActive(true);
    }catch(e){console.log("Kamera nicht verfÃ¼gbar");}
  },[]);

  const processCamera = useCallback(()=>{
    const cam=camRef.current;if(!cam.active||!cam.video||cam.video.readyState<2)return;
    const cv=document.createElement("canvas");cv.width=40;cv.height=30;
    const ctx=cv.getContext("2d");
    ctx.drawImage(cam.video,0,0,40,30);
    const data=ctx.getImageData(0,0,40,30).data;
    const curr=new Float32Array(40*30);
    for(let i=0;i<40*30;i++)curr[i]=(data[i*4]+data[i*4+1]+data[i*4+2])/3;
    if(cam.prevFrame){
      let totalDiff=0,cx=0,cy=0,count=0;
      for(let y=0;y<30;y++){for(let x=0;x<40;x++){
        const diff=Math.abs(curr[y*40+x]-cam.prevFrame[y*40+x]);
        if(diff>15){totalDiff+=diff;cx+=x;cy+=y;count++;}
      }}
      cam.motion=Math.min(100,totalDiff/500);
      if(count>0){cam.x=(1-cx/count/40)*400;cam.y=cy/count/30*400;}// Mirror X
    }
    cam.prevFrame=curr;
  },[]);

  // â”€â”€ THREE.JS SETUP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const init3D = useCallback(()=>{
    if(threeRef.current)return threeRef.current;
    const cv=canvas3DRef.current;if(!cv)return null;
    try{
      const renderer=new THREE.WebGLRenderer({canvas:cv,antialias:true,alpha:false});
      renderer.setSize(400,400);renderer.setPixelRatio(1);
      renderer.shadowMap.enabled=true;
      const scene=new THREE.Scene();
      const camera=new THREE.PerspectiveCamera(55,1,0.1,1000);
      camera.position.set(0,3,7);camera.lookAt(0,0,0);
      const ambient=new THREE.AmbientLight(0x404060,0.6);scene.add(ambient);
      threeRef.current={renderer,scene,camera,ambient,meshes:[],lights:[]};
      return threeRef.current;
    }catch(e){return null;}
  },[]);

  const render3D = useCallback((d3,camData,rot)=>{
    const three=init3D();if(!three)return;
    const{renderer,scene,camera}=three;
    // Clear old meshes and lights
    for(const m of three.meshes)scene.remove(m);
    for(const l of three.lights)scene.remove(l);
    three.meshes=[];three.lights=[];
    scene.background=new THREE.Color("#0a0a14");
    for(const d of d3){
      if(d.t==="box"){
        const g=new THREE.BoxGeometry(d.s,d.s,d.s);
        const m=new THREE.MeshPhongMaterial({color:d.c});
        const mesh=new THREE.Mesh(g,m);mesh.position.set(d.x,d.y,d.z);
        mesh.rotation.x=rot.x;mesh.rotation.y=rot.y;
        scene.add(mesh);three.meshes.push(mesh);
      }else if(d.t==="sphere"){
        const g=new THREE.SphereGeometry(d.r,24,24);
        const m=new THREE.MeshPhongMaterial({color:d.c});
        const mesh=new THREE.Mesh(g,m);mesh.position.set(d.x,d.y,d.z);
        scene.add(mesh);three.meshes.push(mesh);
      }else if(d.t==="cyl"){
        const g=new THREE.CylinderGeometry(d.r,d.r,d.h,16);
        const m=new THREE.MeshPhongMaterial({color:d.c});
        const mesh=new THREE.Mesh(g,m);mesh.position.set(d.x,d.y,d.z);
        scene.add(mesh);three.meshes.push(mesh);
      }else if(d.t==="plane"){
        const g=new THREE.PlaneGeometry(d.w,d.h);
        const m=new THREE.MeshPhongMaterial({color:d.c,side:THREE.DoubleSide});
        const mesh=new THREE.Mesh(g,m);mesh.position.set(d.x,d.y,d.z);
        mesh.rotation.x=-Math.PI/2;
        scene.add(mesh);three.meshes.push(mesh);
      }else if(d.t==="light"){
        const l=new THREE.DirectionalLight(new THREE.Color(d.c),d.i||1);
        l.position.set(d.x,d.y,d.z);
        scene.add(l);three.lights.push(l);
      }
    }
    if(camData){camera.position.set(camData.x,camData.y,camData.z);camera.lookAt(camData.lx,camData.ly,camData.lz);}
    renderer.render(scene,camera);
  },[init3D]);

  // â”€â”€ SHADER RENDERER (cached) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const shaderCacheRef = useRef({src:null,prog:null});
  const initShader = useCallback((fragSrc)=>{
    const cv=shaderRef.current;if(!cv)return null;
    let gl=glRef.current;
    if(!gl){gl=cv.getContext("webgl")||cv.getContext("experimental-webgl");glRef.current=gl;}
    if(!gl)return null;
    // Return cached program if source hasn't changed
    if(shaderCacheRef.current.src===fragSrc&&shaderCacheRef.current.prog)return{prog:shaderCacheRef.current.prog,gl};
    // Clean up old program
    if(shaderCacheRef.current.prog)gl.deleteProgram(shaderCacheRef.current.prog);
    const vs=`attribute vec2 p;void main(){gl_Position=vec4(p,0,1);}`;
    const compile=(t,s)=>{const sh=gl.createShader(t);gl.shaderSource(sh,s);gl.compileShader(sh);return sh;};
    const prog=gl.createProgram();
    gl.attachShader(prog,compile(gl.VERTEX_SHADER,vs));
    gl.attachShader(prog,compile(gl.FRAGMENT_SHADER,fragSrc));
    gl.linkProgram(prog);
    if(!gl.getProgramParameter(prog,gl.LINK_STATUS)){shaderCacheRef.current={src:null,prog:null};return null;}
    gl.useProgram(prog);
    const buf=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,buf);
    gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,1,1]),gl.STATIC_DRAW);
    const pos=gl.getAttribLocation(prog,"p");gl.enableVertexAttribArray(pos);gl.vertexAttribPointer(pos,2,gl.FLOAT,false,0,0);
    shaderCacheRef.current={src:fragSrc,prog};
    return{prog,gl};
  },[]);

  const renderShader = useCallback((fragSrc,time)=>{
    const r=initShader(fragSrc);if(!r)return;
    const{prog,gl}=r;
    gl.useProgram(prog);
    gl.viewport(0,0,400,400);
    const tLoc=gl.getUniformLocation(prog,"zeit");if(tLoc)gl.uniform1f(tLoc,time);
    const rLoc=gl.getUniformLocation(prog,"auflÃ¶sung");if(rLoc)gl.uniform2f(rLoc,400,400);
    const mLoc=gl.getUniformLocation(prog,"maus");if(mLoc)gl.uniform2f(mLoc,mouseRef.current.x,400-mouseRef.current.y);
    gl.drawArrays(gl.TRIANGLE_STRIP,0,4);
  },[initShader]);

  // â”€â”€ MULTIPLAYER POLLING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const mpDataRef = useRef({});
  const pollMultiplayer = useCallback(async()=>{
    if(!window.storage)return;
    try{
      const keys=await window.storage.list("mp:",true);
      if(keys&&keys.keys){
        const fresh={};
        for(const k of keys.keys){
          try{
            const r=await window.storage.get(k,true);
            if(r&&r.value){const d=JSON.parse(r.value);
              if(Date.now()-d.t<10000)fresh[d.id]=d;} // 10s timeout
          }catch(e){}
        }
        mpDataRef.current=fresh;
      }
    }catch(e){}
  },[]);

  // Start/stop multiplayer polling
  const startMPPoll = useCallback(()=>{
    if(mpPollRef.current)return;
    mpPollRef.current=setInterval(pollMultiplayer,500);
  },[pollMultiplayer]);
  const stopMPPoll = useCallback(()=>{
    if(mpPollRef.current){clearInterval(mpPollRef.current);mpPollRef.current=null;}
  },[]);
  useEffect(()=>()=>stopMPPoll(),[stopMPPoll]);

  // â”€â”€ RENDER 2D CANVAS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const renderCanvas = useCallback((draws,turtle)=>{
    const cv=canvasRef.current;if(!cv)return;
    const ctx=cv.getContext("2d");
    ctx.clearRect(0,0,400,400);ctx.fillStyle="#08080f";ctx.fillRect(0,0,400,400);
    ctx.strokeStyle="#ffffff06";ctx.lineWidth=0.5;
    for(let x=0;x<400;x+=40){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,400);ctx.stroke();}
    for(let y=0;y<400;y+=40){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(400,y);ctx.stroke();}
    for(const d of draws){
      if(d.t==="f"){ctx.fillStyle=d.c;ctx.fillRect(0,0,400,400);continue;}
      ctx.fillStyle=d.c||"#fff";ctx.strokeStyle=d.c||"#fff";
      if(d.t==="c"){ctx.beginPath();ctx.arc(d.x,d.y,Math.max(0.5,d.r),0,Math.PI*2);ctx.fill();}
      else if(d.t==="l"){ctx.lineWidth=d.w||2;ctx.beginPath();ctx.moveTo(d.x1,d.y1);ctx.lineTo(d.x2,d.y2);ctx.stroke();}
      else if(d.t==="r"){ctx.fillRect(d.x,d.y,d.w,d.h);}
      else if(d.t==="tx"){ctx.font=`${d.s||16}px 'Outfit',sans-serif`;ctx.fillText(d.txt,d.x,d.y);}
    }
    if(turtle&&turtle.vis){
      const ta=turtle.a*Math.PI/180;ctx.save();ctx.translate(turtle.x,turtle.y);ctx.rotate(ta);
      ctx.beginPath();ctx.moveTo(10,0);ctx.lineTo(-6,-6);ctx.lineTo(-3,0);ctx.lineTo(-6,6);ctx.closePath();
      ctx.fillStyle="#f43f5ecc";ctx.fill();ctx.strokeStyle="#fff";ctx.lineWidth=1;ctx.stroke();ctx.restore();
    }
  },[]);

  // â”€â”€ STOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const stopAnim = useCallback(()=>{
    if(animRef.current){cancelAnimationFrame(animRef.current);animRef.current=null;}
    setIsAnim(false);setIs3D(false);setIsShader(false);stopMPPoll();
    shaderCacheRef.current={src:null,prog:null};
  },[stopMPPoll]);

  // â”€â”€ RUN CODE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const runCode = useCallback(()=>{
    stopAnim();
    const js=compileGerman(code);
    const output=[],errors=[],draws=[];
    if(!audioRef.current){try{audioRef.current=new(window.AudioContext||window.webkitAudioContext)();}catch(e){}}

    const camCtrl={start:()=>startCamera(),stop:()=>{camRef.current.active=false;setCamActive(false);}};
    const storageAPI=window.storage||null;

    try{
      const allRT=`${RUNTIME}\n${TURTLE_RT}\n${SOUND_RT}\n${PHYSICS_RT}\n${PARTICLE_RT}\n${GAME_RT}\n${CAMERA_RT}\n${KI_RT}\n${THREE_RT}\n${MULTI_RT}\n${SHADER_RT}\n`;
      const hasAnim=/^funktion zeichne\(\)\s*:/m.test(code);
      const has3D=/szene_3d|wÃ¼rfel_3d|kugel_3d|zylinder_3d|ebene_3d/.test(code);
      const hasCam=/kamera_starten/.test(code);
      const hasShader=/\bshader\s*\(/.test(code);
      const hasMP=/mehrspieler_/.test(code);

      if(hasCam)startCamera();
      if(hasMP)startMPPoll();

      if(hasAnim){
        const scopedCode=`${allRT}
let rahmen=0,maus_x=0,maus_y=0,maus_gedrÃ¼ckt=false;
${js}
return{zeichne:typeof zeichne==='function'?zeichne:null,
  setMouse(x,y,d){maus_x=x;maus_y=y;maus_gedrÃ¼ckt=d},
  setFrame(f){rahmen=f},
  setCam(x,y,m){kamera_x=x;kamera_y=y;kamera_bewegung=m;kamera_aktiv=true;},
  setMP(d){__mp_alle=d;},
  getDraws(){const r=[...__d];__d.length=0;return r},
  get3D(){const r={cmds:[...__d3],cam:{...__3d_cam},rot:{...__3d_rot},bg:__3d_bg,mode:__3d_mode};__d3.length=0;return r},
  getShader(){return{mode:__shader_mode,code:__shader_code,uniforms:{...__shader_uniforms}}},
  getTurtle(){return __turtle}};`;
        const scopedFn=new Function("__out","__err","__d","__d3","__audioCtx","__keys","__cam","__storage",scopedCode);
        const scope={out:[],err:[],d:[],d3:[]};
        const ctx=scopedFn(scope.out,scope.err,scope.d,scope.d3,audioRef.current,keysRef.current,camCtrl,storageAPI);
        if(ctx.zeichne){
          setIsAnim(true);if(has3D)setIs3D(true);if(hasShader)setIsShader(true);let frame=0;
          const animate=()=>{
            scope.out.length=0;
            processCamera();
            ctx.setMouse(mouseRef.current.x,mouseRef.current.y,mouseRef.current.down);
            ctx.setFrame(frame);
            ctx.setCam(camRef.current.x,camRef.current.y,camRef.current.motion);
            ctx.setMP(mpDataRef.current);
            try{ctx.zeichne();}catch(e){setConsoleOut([{ty:"err",t:"âš  "+tErr(e.message)}]);stopAnim();return;}
            const info3d=ctx.get3D();
            const shInfo=ctx.getShader();
            const draws2d=ctx.getDraws(); // Always consume to prevent memory leak
            if(shInfo.mode){renderShader(shInfo.code,frame/60);}
            else if(info3d.mode){render3D(info3d.cmds,info3d.cam,info3d.rot);}
            else{renderCanvas(draws2d,ctx.getTurtle());}
            frame++;animRef.current=requestAnimationFrame(animate);
          };
          animRef.current=requestAnimationFrame(animate);
          const features=[];if(has3D)features.push("3D");if(hasCam)features.push("Kamera");if(hasMP)features.push("Multi");if(hasShader)features.push("Shader");
          setConsoleOut([{ty:"sys",t:`ğŸ”„ Animation lÃ¤uft... ${features.length?`[${features.join("+")}]`:""} (${code.split("\n").length} Zeilen)`}]);
        }
      }else{
        const fullCode=`${allRT}\nconst __d3=[];\n${js}\nreturn{turtle:__turtle,d3:__d3,mode3d:__3d_mode,cam3d:__3d_cam,rot3d:__3d_rot,bg3d:__3d_bg,shader_mode:__shader_mode,shader_code:__shader_code};`;
        const fn=new Function("__out","__err","__d","__audioCtx","__keys","__cam","__storage","rahmen","maus_x","maus_y","maus_gedrÃ¼ckt",fullCode);
        const result=fn(output,errors,draws,audioRef.current,keysRef.current,camCtrl,storageAPI,0,mouseRef.current.x,mouseRef.current.y,mouseRef.current.down);

        if(result.shader_mode){setIsShader(true);renderShader(result.shader_code,0);}
        else if(result.mode3d){setIs3D(true);render3D(result.d3,result.cam3d,result.rot3d);}
        else{renderCanvas(draws,result.turtle);}

        const lines=output.map(o=>({ty:"out",t:String(o)}));
        errors.forEach(e=>lines.push({ty:"err",t:"âš  "+tErr(e)}));
        if(!lines.length)lines.push({ty:"sys",t:"âœ“ "+(result.shader_mode?"Shader aktiv":result.mode3d?result.d3.length+" 3D-Objekte":draws.length+" Zeichenbefehle")});
        setConsoleOut(lines);

        if(showDebug){
          const vars={};
          const vm=code.matchAll(/^(\s*)([\wÃ¤Ã¶Ã¼Ã„Ã–ÃœÃŸ]+)\s*=\s*(.+)$/gm);
          for(const m of vm){if(!["funktion","fÃ¼r","wenn","solange","sonst","klasse"].includes(m[2]))vars[m[2]]=m[3].trim();}
          setDebugVars(vars);
        }
      }
    }catch(e){setConsoleOut([{ty:"err",t:"âš  "+tErr(e.message)}]);renderCanvas([],null);}
  },[code,stopAnim,renderCanvas,render3D,renderShader,showDebug,startCamera,processCamera,startMPPoll]);

  // Auto-run
  useEffect(()=>{
    if(/^funktion zeichne\(\)\s*:/m.test(code)){setConsoleOut([{ty:"sys",t:"ğŸ”„ Animation erkannt â€” drÃ¼cke â–¶ AusfÃ¼hren"}]);return;}
    stopAnim();runCode();
  },[code]);
  useEffect(()=>{if(consoleRef.current)consoleRef.current.scrollTop=consoleRef.current.scrollHeight;},[consoleOut]);
  useEffect(()=>{const h=e=>{if((e.ctrlKey||e.metaKey)&&e.key==="Enter"){e.preventDefault();runCode()}};
    window.addEventListener("keydown",h);return()=>window.removeEventListener("keydown",h);},[runCode]);

  // â”€â”€ VOICE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const startVoice=async()=>{setTranscript("");setInterim("");try{recRef.current?.start();setListening(true);}catch(e){}
    try{const stream=await navigator.mediaDevices.getUserMedia({audio:true});const actx=new(window.AudioContext||window.webkitAudioContext)();
      const src=actx.createMediaStreamSource(stream);const an=actx.createAnalyser();an.fftSize=256;src.connect(an);
      const cv=waveRef.current;if(!cv)return;const ctx=cv.getContext("2d");const W=cv.width,H=cv.height;const buf=new Uint8Array(an.frequencyBinCount);
      const draw=()=>{waveAnimRef.current=requestAnimationFrame(draw);an.getByteFrequencyData(buf);ctx.clearRect(0,0,W,H);
        for(let i=0;i<64;i++){const v=buf[i]/255;const h=v*H*.9;ctx.fillStyle=`hsla(${v*30},85%,${50+v*20}%,${.5+v*.5})`;
          ctx.fillRect(i*(W/64)+1,H-h,W/64-2,h);}};draw();}catch(e){}};
  const stopVoice=()=>{setListening(false);try{recRef.current?.stop();}catch(e){}if(waveAnimRef.current)cancelAnimationFrame(waveAnimRef.current);};

  // â”€â”€ AI (Smart Demos + optional Live API) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const AI_DEMOS={"3D-Stadt mit Kugeln":`funktion zeichne():
    szene_3d("#0a0a1e")
    licht_3d(5, 8, 5)
    ebene_3d(0, -1, 0, 30, 30, "#1a1a2e")
    
    fÃ¼r i in bereich(0, 6):
        fÃ¼r j in bereich(0, 6):
            h = 0.5 + sinus(i + rahmen * 0.03) * kosinus(j + rahmen * 0.02) * 2
            wÃ¼rfel_3d(i * 2 - 5, h / 2, j * 2 - 5, h, "hsl(" + zeichenkette(i * 40 + j * 20) + ",70%,55%)")
    
    fÃ¼r k in bereich(0, 8):
        winkel = rahmen * 0.015 + k * 0.785
        kugel_3d(kosinus(winkel) * 6, 2 + sinus(rahmen * 0.04 + k) * 1.5, sinus(winkel) * 6, 0.6, "hsl(" + zeichenkette(k * 45 + rahmen) + ",80%,65%)")
    
    drehen_3d(0, 0.3, 0)`,
"Physik BÃ¤lle Demo":`schwerkraft(0.5)
boden = kÃ¶rper(0, 380, 400, 20, {"fest": wahr, "farbe": "#1a1a2e"})
kÃ¶rper(0, 200, 10, 200, {"fest": wahr, "farbe": "#2a1a3e", "winkel": 0.3})
kÃ¶rper(390, 200, 10, 200, {"fest": wahr, "farbe": "#2a1a3e", "winkel": -0.3})

fÃ¼r i in bereich(0, 15):
    kÃ¶rper(50 + (i % 5) * 70, 10 + ganzzahl(i / 5) * 40, 18 + (i % 3) * 8, 18 + (i % 3) * 8, {"farbe": "hsl(" + zeichenkette(i * 24) + ",85%,60%)", "reibung": 0.3})

funktion zeichne():
    fÃ¼lle("#0a0a14")
    physik_schritt()
    alle_kÃ¶rper_zeichnen()
    
    wenn maus_gedrÃ¼ckt:
        kÃ¶rper(maus_x, maus_y, 15, 15, {"farbe": "hsl(" + zeichenkette(rahmen * 3) + ",90%,65%)"})`,
"Partikel-Feuerwerk":`funktion zeichne():
    fÃ¼lle("rgba(5,5,10,0.15)")
    
    wenn rahmen % 30 == 0:
        x = 50 + zufall() * 300
        y = 50 + zufall() * 150
        partikel_explosion(x, y, "hsl(" + zeichenkette(zufall() * 360) + ",90%,65%)", 60)
    
    wenn rahmen % 45 == 15:
        partikel_explosion(200, 200, "#f43f5e", 40)
    
    wenn rahmen % 45 == 30:
        partikel_explosion(100 + zufall() * 200, 100 + zufall() * 200, "#38bdf8", 50)
    
    partikel_regen(0, "#fbbf2440", 2)
    partikel_aktualisieren()
    
    wenn maus_gedrÃ¼ckt:
        partikel_explosion(maus_x, maus_y, "#facc15", 30)`,
"Pong-Spiel":`schlÃ¤ger_y = 180
ball_x = 200
ball_y = 200
ball_vx = 3
ball_vy = 2
ki_y = 180
punkte = 0

funktion zeichne():
    fÃ¼lle("#0a0a14")
    
    wenn taste("hoch"):
        schlÃ¤ger_y = schlÃ¤ger_y - 5
    wenn taste("runter"):
        schlÃ¤ger_y = schlÃ¤ger_y + 5
    
    ball_x = ball_x + ball_vx
    ball_y = ball_y + ball_vy
    
    wenn ball_y < 5 oder ball_y > 395:
        ball_vy = ball_vy * -1
    
    ki_y = ki_y + (ball_y - ki_y - 20) * 0.06
    
    wenn ball_x < 25 und ball_y > schlÃ¤ger_y und ball_y < schlÃ¤ger_y + 60:
        ball_vx = absolut(ball_vx) * 1.05
        punkte = punkte + 1
    
    wenn ball_x > 375 und ball_y > ki_y und ball_y < ki_y + 60:
        ball_vx = -absolut(ball_vx)
    
    wenn ball_x < 0 oder ball_x > 400:
        ball_x = 200
        ball_y = 200
        ball_vx = 3
    
    farbe("#38bdf8")
    rechteck(15, schlÃ¤ger_y, 10, 60)
    farbe("#f43f5e")
    rechteck(375, ki_y, 10, 60)
    farbe("#facc15")
    kreis(ball_x, ball_y, 8)
    
    farbe("#ffffff")
    text("Punkte: " + zeichenkette(punkte), 170, 30)`,
"Kamera-Steuerung":`x = 200
y = 200
geschwindigkeit = 4
grÃ¶ÃŸe = 20
spur = []

funktion zeichne():
    fÃ¼lle("#0a0a14")
    
    wenn taste("links"):
        x = x - geschwindigkeit
    wenn taste("rechts"):
        x = x + geschwindigkeit
    wenn taste("hoch"):
        y = y - geschwindigkeit
    wenn taste("runter"):
        y = y + geschwindigkeit
    
    spur.anhÃ¤ngen([x, y])
    wenn lÃ¤nge(spur) > 50:
        spur.entfernen(spur[0])
    
    fÃ¼r i in bereich(0, lÃ¤nge(spur)):
        alpha = i / lÃ¤nge(spur)
        farbe("hsla(" + zeichenkette(i * 7) + ",80%,60%," + zeichenkette(alpha * 0.5) + ")")
        kreis(spur[i][0], spur[i][1], grÃ¶ÃŸe * alpha)
    
    farbe("hsl(" + zeichenkette(rahmen * 2) + ",85%,65%)")
    kreis(x, y, grÃ¶ÃŸe)
    
    farbe("#ffffff50")
    text("â† â†’ â†‘ â†“ Pfeiltasten", 120, 390)`,
"KI die Farben lernt":`ki = ki_erstellen()

ki_lernen(ki, "Warm", [255, 100, 50])
ki_lernen(ki, "Warm", [200, 80, 30])
ki_lernen(ki, "Warm", [255, 200, 0])
ki_lernen(ki, "Kalt", [50, 100, 255])
ki_lernen(ki, "Kalt", [30, 80, 200])
ki_lernen(ki, "Kalt", [100, 200, 255])
ki_lernen(ki, "Natur", [50, 200, 50])
ki_lernen(ki, "Natur", [80, 180, 30])
ki_lernen(ki, "Natur", [100, 255, 100])

farben = [[255, 50, 50], [50, 50, 255], [50, 200, 50], [255, 165, 0], [0, 255, 255], [200, 100, 200]]

drucke("=== KI Farberkennung ===")
fÃ¼r f in farben:
    ergebnis = ki_vorhersagen(ki, f)
    drucke("RGB(" + zeichenkette(f[0]) + "," + zeichenkette(f[1]) + "," + zeichenkette(f[2]) + ") â†’ " + ergebnis)

drucke("")
drucke("Genauigkeit: " + zeichenkette(ki_genauigkeit(ki)) + "%")`,
"Mehrspieler Cursor-Jagd":`x = 200
y = 200

funktion zeichne():
    fÃ¼lle("#0a0a14")
    
    x = x + (maus_x - x) * 0.08
    y = y + (maus_y - y) * 0.08
    mehrspieler_senden("x", x)
    mehrspieler_senden("y", y)
    
    gx = mehrspieler_empfangen("x")
    gy = mehrspieler_empfangen("y")
    
    fÃ¼r i in bereich(0, 12):
        winkel = rahmen * 0.05 + i * 0.524
        farbe("hsla(" + zeichenkette(i * 30 + rahmen) + ",80%,60%,0.4)")
        kreis(x + kosinus(winkel) * 30, y + sinus(winkel) * 30, 6)
    
    farbe("#f43f5e")
    kreis(x, y, 12)
    
    wenn gx und gy:
        farbe("#38bdf8")
        kreis(gx, gy, 12)
        abstand = wurzel((x - gx) * (x - gx) + (y - gy) * (y - gy))
        wenn abstand < 25:
            partikel_explosion(x, y, "#facc15", 30)
    
    partikel_aktualisieren()`,
"Plasma-Shader":`shader(\`
precision mediump float;
uniform float u_time;
uniform vec2 u_resolution;
void main(){
    vec2 uv = gl_FragCoord.xy / u_resolution;
    float t = u_time * 0.4;
    float v = 0.0;
    v += sin(uv.x * 10.0 + t);
    v += sin((uv.y * 10.0 + t) * 0.5);
    v += sin((uv.x * 10.0 + uv.y * 10.0 + t) * 0.3);
    v += sin(length(uv - 0.5) * 15.0 - t * 2.0);
    vec3 col = vec3(
        sin(v * 3.14159 + 0.0) * 0.5 + 0.5,
        sin(v * 3.14159 + 2.094) * 0.5 + 0.5,
        sin(v * 3.14159 + 4.189) * 0.5 + 0.5
    );
    gl_FragColor = vec4(col * 0.9, 1.0);
}\`)`,
"SchildkrÃ¶te Mandala":`schildkrÃ¶te.geschwindigkeit(0)
farben = ["#f43f5e", "#38bdf8", "#facc15", "#2dd4bf", "#a78bfa", "#fb923c"]

fÃ¼r ring in bereich(0, 6):
    schildkrÃ¶te.farbe(farben[ring % 6])
    fÃ¼r i in bereich(0, 36):
        schildkrÃ¶te.vorwÃ¤rts(5 + ring * 15)
        schildkrÃ¶te.rechts(80)
        schildkrÃ¶te.vorwÃ¤rts(5 + ring * 10)
        schildkrÃ¶te.links(70)
        schildkrÃ¶te.rechts(10)`,
"Planetensystem":`funktion zeichne():
    szene_3d("#050510")
    licht_3d(0, 3, 0)
    
    kugel_3d(0, 0, 0, 1.5, "#facc15")
    
    planeten = [[3, 0.8, "#38bdf8", 0.02], [5, 0.5, "#f43f5e", 0.012], [7, 0.6, "#2dd4bf", 0.008], [9.5, 1.0, "#fb923c", 0.005], [12, 0.4, "#a78bfa", 0.018]]
    
    fÃ¼r p in planeten:
        winkel = rahmen * p[3]
        px = kosinus(winkel) * p[0]
        pz = sinus(winkel) * p[0]
        kugel_3d(px, 0, pz, p[1], p[2])
        
        fÃ¼r m in bereich(0, 2):
            mw = rahmen * 0.05 + m * 3.14
            kugel_3d(px + kosinus(mw) * 1.2, 0.3, pz + sinus(mw) * 1.2, 0.15, "#ffffff80")
    
    drehen_3d(0.3, 0.2, 0)`};
  const sendToAI=async(prompt)=>{if(!prompt.trim()||aiLoading)return;setAiLoading(true);setAiInput("");
    const key=Object.keys(AI_DEMOS).find(k=>prompt.toLowerCase().includes(k.toLowerCase())||k.toLowerCase().includes(prompt.toLowerCase()));
    if(key){const demo=AI_DEMOS[key];let i=0;const iv=setInterval(()=>{i+=Math.floor(Math.random()*8)+5;if(i>=demo.length){clearInterval(iv);setCode(demo);setTimeout(()=>setShowAI(false),300);setAiLoading(false);}else{setCode(demo.slice(0,i)+"â–ˆ");}},25);return;}
    setCode("# KI-Demo: "+prompt+"\n# WÃ¤hle eines der vorgeschlagenen Beispiele\n# oder beschreibe es genauer!");setShowAI(false);setAiLoading(false);};

  const askTutor=async(q)=>{if(!q.trim()||tutorLoading)return;setTutorLoading(true);setTutorQ("");
    const hints={"was":"Dieser Code nutzt Black Swan â€” die deutsche Programmiersprache. Jeder Befehl ist auf Deutsch und wird zu Python transpiliert!",
      "wie":"Der Code wird zuerst von Deutsch nach JavaScript Ã¼bersetzt (Compiler), dann ausgefÃ¼hrt. Du kannst auch den Python-Code sehen (ğŸ Button)!",
      "fehler":"PrÃ¼fe ob alle Befehle richtig geschrieben sind. Tipp: Klick auf ein Galerie-Beispiel und studiere den Code!",
      "hilf":"Versuch die Galerie-Beispiele links anzuklicken. Jedes zeigt eine andere Funktion von Black Swan. Du kannst den Code Ã¤ndern und experimentieren!"};
    const a=Object.entries(hints).find(([k])=>q.toLowerCase().includes(k));
    setTimeout(()=>{setTutorA(a?a[1]:"Black Swan ist eine deutsche Programmiersprache. Probier die Beispiele links aus â€” du kannst den Code Ã¤ndern und auf â–¶ AusfÃ¼hren klicken!");setTutorLoading(false);},800);};

  const sidePanel=showPy?"py":showDebug?"debug":showTutor?"tutor":null;
  const togglePanel=p=>{setShowPy(p==="py"?!showPy:false);setShowDebug(p==="debug"?!showDebug:false);setShowTutor(p==="tutor"?!showTutor:false);};
  const modeLabel=isShader?"ğŸŒ SHADER":is3D?"ğŸ§Š 3D":(/taste\(/.test(code)&&isAnim)?"ğŸ® GAME":camActive?"ğŸ–ï¸ CAM":(/mehrspieler_/.test(code)&&isAnim)?"ğŸ‘¥ MULTI":isAnim?"ğŸ”„ LIVE":"â— Bereit";

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const Btn=({onClick,active,color,children,title})=>(
    <button onClick={onClick} title={title} style={{padding:"4px 10px",borderRadius:14,
      border:`1px solid ${color||C.DM}${active?"60":"22"}`,
      background:active?`${color||C.DM}15`:"transparent",
      color:color||C.DM,cursor:"pointer",fontFamily:"'Outfit'",
      fontSize:10,fontWeight:600,whiteSpace:"nowrap",transition:"all .15s"}}>{children}</button>);

  return(
    <div style={{height:"100vh",display:"flex",flexDirection:"column",background:C.BG,
      color:C.TX,fontFamily:"'Fira Code',monospace",overflow:"hidden"}}>
      <style>{`
@import url('https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;700;800;900&family=Fira+Code:wght@400;500&display=swap');
*{box-sizing:border-box;margin:0;padding:0}
::-webkit-scrollbar{width:3px}::-webkit-scrollbar-track{background:transparent}::-webkit-scrollbar-thumb{background:${C.BD};border-radius:3px}
textarea:focus,input:focus{outline:none}::selection{background:${C.R}30}
@keyframes fadeUp{from{opacity:0;transform:translateY(6px)}to{opacity:1;transform:translateY(0)}}
@keyframes fadeIn{from{opacity:0}to{opacity:1}}
@keyframes breathe{0%,100%{box-shadow:0 0 0 0 ${C.R}40}50%{box-shadow:0 0 20px 4px ${C.R}10}}
@keyframes spin{from{transform:rotate(0)}to{transform:rotate(360deg)}}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:0.5}}
@keyframes glow3d{0%,100%{box-shadow:0 0 15px ${C.B}15}50%{box-shadow:0 0 30px ${C.B}25}}
@keyframes glowShader{0%,100%{box-shadow:0 0 15px ${C.P}15}50%{box-shadow:0 0 30px ${C.P}25}}
      `}</style>

      {/* HEADER */}
      <div style={{display:"flex",alignItems:"center",justifyContent:"space-between",
        padding:"0 12px",height:40,flexShrink:0,borderBottom:`1px solid ${C.BD}40`,
        background:`linear-gradient(180deg,${C.S2}ee,${C.BG})`}}>
        <div style={{display:"flex",alignItems:"center",gap:10}}>
          <div style={{fontFamily:"'Outfit'",fontWeight:900,fontSize:14,display:"flex",alignItems:"center",gap:5}}>
            <span style={{fontSize:16}}>ğŸ¦¢</span>
            <span style={{background:`linear-gradient(135deg,${C.R},${C.O})`,WebkitBackgroundClip:"text",WebkitTextFillColor:"transparent"}}>BLACK SWAN</span>
          </div>
          <div style={{fontSize:7,color:C.DM,fontFamily:"'Outfit'",padding:"2px 6px",borderRadius:6,border:`1px solid ${C.DM}25`,letterSpacing:1}}>OMEGA v16</div>
        </div>
        <div style={{display:"flex",gap:3,alignItems:"center",flexWrap:"wrap"}}>
          <button onClick={isAnim?stopAnim:runCode} style={{padding:"4px 12px",borderRadius:14,border:"none",
            cursor:"pointer",background:isAnim?C.R:`linear-gradient(135deg,${C.T},${C.B})`,
            color:"#fff",fontFamily:"'Outfit'",fontSize:10,fontWeight:700}}>{isAnim?"â¹ Stopp":"â–¶ AusfÃ¼hren"}</button>
          {voiceOK&&<Btn onClick={()=>{setShowVoice(true);startVoice()}} color={C.O}>ğŸ¤</Btn>}
          <Btn onClick={()=>setShowAI(true)} color={C.P}>ğŸ¤– KI</Btn>
          <div style={{width:1,height:14,background:C.BD+"40",margin:"0 1px"}}/>
          <Btn onClick={()=>togglePanel("py")} active={showPy} color={C.B}>ğŸ</Btn>
          <Btn onClick={()=>togglePanel("debug")} active={showDebug} color={C.Y}>ğŸ”„</Btn>
          <Btn onClick={()=>togglePanel("tutor")} active={showTutor} color={C.T}>ğŸ§ </Btn>
          <Btn onClick={()=>{const cv=isShader?shaderRef.current:is3D?canvas3DRef.current:canvasRef.current;
            if(!cv)return;const a=document.createElement("a");a.download="black-swan.png";a.href=cv.toDataURL();a.click();}} color={C.DM} title="Canvas speichern">ğŸ’¾</Btn>
        </div>
      </div>

      {/* MAIN */}
      <div style={{flex:1,display:"flex",overflow:"hidden"}}>
        {/* Gallery */}
        <div style={{width:46,background:C.S1,borderRight:`1px solid ${C.BD}30`,
          display:"flex",flexDirection:"column",alignItems:"center",padding:"4px 0",gap:2,overflowY:"auto",flexShrink:0}}>
          {GALLERY.map((g,i)=>(
            <button key={i} onClick={()=>{setActiveG(i);stopAnim();setCode(g.c)}} title={g.t+" â€” "+g.d}
              style={{width:34,height:34,borderRadius:6,fontSize:13,
                border:`1px solid ${activeG===i?C.R+"50":C.BD+"20"}`,
                background:activeG===i?C.R+"15":"transparent",cursor:"pointer",
                display:"flex",alignItems:"center",justifyContent:"center",transition:"all .15s"}}>{g.t.split(" ")[0]}</button>
          ))}
        </div>

        {/* Editor */}
        <div style={{width:sidePanel?280:360,display:"flex",flexDirection:"column",
          borderRight:`1px solid ${C.BD}30`,flexShrink:0,transition:"width .2s",minWidth:220}}>
          <div style={{flex:1,position:"relative",overflow:"hidden"}}>
            <pre style={{position:"absolute",inset:0,margin:0,padding:"8px 10px",fontSize:11,
              lineHeight:1.7,fontFamily:"inherit",overflow:"auto",pointerEvents:"none",
              whiteSpace:"pre-wrap",wordBreak:"break-all",background:"transparent",zIndex:1}}
              dangerouslySetInnerHTML={{__html:hlDE(code)}} />
            <textarea value={code} onChange={e=>{stopAnim();setCode(e.target.value)}}
              spellCheck={false} style={{position:"absolute",inset:0,width:"100%",height:"100%",
                padding:"8px 10px",fontSize:11,lineHeight:1.7,fontFamily:"inherit",
                background:C.BG,color:"transparent",caretColor:C.R,border:"none",
                resize:"none",whiteSpace:"pre-wrap",wordBreak:"break-all",zIndex:2}} />
          </div>
          <div style={{height:75,borderTop:`1px solid ${C.BD}30`,flexShrink:0}}>
            <div ref={consoleRef} style={{height:"100%",overflow:"auto",padding:"5px 10px",
              background:`${C.S1}80`,fontSize:9,lineHeight:1.5}}>
              {consoleOut.map((l,i)=>(
                <div key={i} style={{color:l.ty==="err"?C.R:l.ty==="sys"?C.DM:C.T,
                  animation:`fadeUp .1s ease ${i*.01}s both`}}>{l.t}</div>))}
            </div>
          </div>
        </div>

        {/* SIDE PANEL */}
        {sidePanel&&(
          <div style={{width:220,borderRight:`1px solid ${C.BD}30`,flexShrink:0,
            animation:"fadeIn .15s ease",display:"flex",flexDirection:"column",overflow:"hidden"}}>
            {showPy&&(<>
              <div style={{padding:"4px 10px",fontSize:7,letterSpacing:2,color:C.B,fontFamily:"'Outfit'",fontWeight:700,borderBottom:`1px solid ${C.BD}30`}}>ğŸ PYTHON</div>
              <pre style={{flex:1,margin:0,padding:"8px 10px",fontSize:10,lineHeight:1.7,fontFamily:"inherit",overflow:"auto",whiteSpace:"pre-wrap",background:C.BG,color:C.DM}}>{deToEn(code)}</pre>
            </>)}
            {showDebug&&(<>
              <div style={{padding:"4px 10px",fontSize:7,letterSpacing:2,color:C.Y,fontFamily:"'Outfit'",fontWeight:700,borderBottom:`1px solid ${C.BD}30`}}>ğŸ”„ VARIABLEN</div>
              <div style={{flex:1,overflow:"auto",padding:"6px 8px",fontSize:9.5}}>
                {Object.keys(debugVars).length===0?
                  <div style={{color:C.DM,fontFamily:"'Outfit'",fontSize:10,padding:6}}>FÃ¼hre Code aus um Variablen zu sehen.</div>:
                  Object.entries(debugVars).map(([k,v],i)=>(
                    <div key={k} style={{display:"flex",justifyContent:"space-between",padding:"3px 5px",borderRadius:4,marginBottom:1,background:i%2===0?C.S1+"80":"transparent"}}>
                      <span style={{color:C.Y}}>{k}</span><span style={{color:C.T,maxWidth:100,overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap"}}>{v}</span>
                    </div>))}
                <div style={{marginTop:10,padding:"5px 7px",borderRadius:5,background:C.S1,border:`1px solid ${C.BD}30`,fontSize:8,color:C.DM}}>
                  <div style={{fontFamily:"'Outfit'",fontWeight:600,marginBottom:3}}>v16 OMEGA APIs:</div>
                  <div>ğŸ‘¥ mehrspieler_senden/lesen</div>
                  <div>ğŸŒ shader Â· shader_wert</div>
                  <div>ğŸ§Š szene_3d Â· wÃ¼rfel_3d Â· kugel_3d</div>
                  <div>ğŸ–ï¸ kamera_starten Â· kamera_x/y</div>
                  <div>ğŸ§  ki_erstellen Â· ki_lernen</div>
                  <div>âš›ï¸ schwerkraft Â· kÃ¶rper Â· kraft</div>
                  <div>ğŸ­ partikel_explosion</div>
                  <div>ğŸ® taste Â· spielobjekt Â· bewege</div>
                </div>
              </div>
            </>)}
            {showTutor&&(<>
              <div style={{padding:"4px 10px",fontSize:7,letterSpacing:2,color:C.T,fontFamily:"'Outfit'",fontWeight:700,borderBottom:`1px solid ${C.BD}30`}}>ğŸ§  KI-TUTOR</div>
              <div style={{flex:1,overflow:"auto",padding:"6px 8px",display:"flex",flexDirection:"column",gap:6}}>
                <div style={{display:"flex",flexWrap:"wrap",gap:2}}>
                  {["Was macht das?","Verbesserungen?","Zeile fÃ¼r Zeile","Fehler?"].map(q=>(
                    <button key={q} onClick={()=>askTutor(q)} style={{padding:"2px 7px",borderRadius:5,border:`1px solid ${C.BD}`,background:C.S1,color:C.TX,cursor:"pointer",fontSize:8,fontFamily:"'Outfit'"}}>{q}</button>))}
                </div>
                <div style={{display:"flex",gap:3}}>
                  <input value={tutorQ} onChange={e=>setTutorQ(e.target.value)} onKeyDown={e=>{if(e.key==="Enter")askTutor(tutorQ)}}
                    placeholder="Frage..." style={{flex:1,padding:"5px 7px",borderRadius:5,border:`1px solid ${C.BD}`,background:C.S1,color:C.TX,fontSize:9.5,fontFamily:"'Outfit'"}} />
                  <button onClick={()=>askTutor(tutorQ)} style={{padding:"5px 8px",borderRadius:5,border:"none",cursor:"pointer",background:C.T,color:"#000",fontSize:9,fontWeight:700}}>
                    {tutorLoading?"â³":"â†’"}</button>
                </div>
                {tutorA&&<div style={{padding:"7px 8px",borderRadius:5,background:C.S1,border:`1px solid ${C.T}20`,fontSize:10,lineHeight:1.6,fontFamily:"'Outfit'",color:C.TX,animation:"fadeUp .2s ease"}}>{tutorA}</div>}
                {!tutorA&&!tutorLoading&&<div style={{color:C.DM,fontFamily:"'Outfit'",fontSize:9.5,padding:4}}>Frage den KI-Tutor! ğŸ‡©ğŸ‡ª</div>}
              </div>
            </>)}
          </div>
        )}

        {/* CANVAS AREA */}
        <div style={{flex:1,display:"flex",alignItems:"center",justifyContent:"center",
          background:`radial-gradient(ellipse at center,${C.S2},${C.BG})`,position:"relative"}}>
          <div style={{position:"absolute",inset:0,backgroundImage:`radial-gradient(circle at 1px 1px, ${C.BD}15 1px, transparent 0)`,backgroundSize:"40px 40px"}} />
          {/* Canvas wrapper â€” contains all canvases + mouse overlay */}
          <div style={{position:"relative",width:400,height:400,maxWidth:"100%",maxHeight:"calc(100vh - 80px)",zIndex:1}}>
            {/* 2D Canvas */}
            <canvas ref={canvasRef} width={400} height={400} style={{
              borderRadius:8,border:`1px solid ${C.BD}40`,width:"100%",height:"100%",
              boxShadow:`0 0 40px ${C.R}04`,
              display:(is3D||isShader)?"none":"block"}} />
            {/* 3D Canvas */}
            <canvas ref={canvas3DRef} width={400} height={400} style={{
              borderRadius:8,border:`1px solid ${C.B}40`,width:"100%",height:"100%",
              boxShadow:`0 0 40px ${C.B}08`,
              display:is3D&&!isShader?"block":"none",
              animation:is3D?"glow3d 3s ease infinite":"none"}} />
            {/* Shader Canvas (WebGL) */}
            <canvas ref={shaderRef} width={400} height={400} style={{
              borderRadius:8,border:`1px solid ${C.P}40`,width:"100%",height:"100%",
              boxShadow:`0 0 40px ${C.P}08`,
              display:isShader?"block":"none",
              animation:isShader?"glowShader 3s ease infinite":"none"}} />
            {/* Mouse/Touch overlay â€” captures events for ALL canvas modes */}
            <div ref={mouseOverlayRef} style={{position:"absolute",inset:0,zIndex:3,cursor:"crosshair",borderRadius:8}} />
          </div>
          {/* Mode badge */}
          {isAnim&&<div style={{position:"absolute",top:8,right:12,
            padding:"3px 10px",borderRadius:10,
            background:isShader?`${C.P}20`:is3D?`${C.B}20`:`${C.R}20`,
            border:`1px solid ${isShader?C.P:is3D?C.B:C.R}25`,fontSize:8,
            color:isShader?C.P:is3D?C.B:C.R,fontFamily:"'Outfit'",fontWeight:700,zIndex:2,
            animation:"breathe 2s ease infinite",letterSpacing:1}}>{modeLabel}</div>}
          {/* Cam indicator */}
          {camActive&&<div style={{position:"absolute",top:8,left:12,
            padding:"3px 8px",borderRadius:8,background:`${C.O}20`,border:`1px solid ${C.O}25`,
            fontSize:8,color:C.O,fontFamily:"'Outfit'",fontWeight:700,zIndex:2,
            animation:"pulse 1.5s infinite"}}>ğŸ“· Kamera aktiv</div>}
          {/* Game hint */}
          {isAnim&&/taste\(/.test(code)&&!is3D&&(
            <div style={{position:"absolute",bottom:8,right:12,padding:"3px 8px",borderRadius:8,
              background:`${C.S1}cc`,border:`1px solid ${C.BD}40`,fontSize:7,color:C.DM,fontFamily:"'Outfit'",zIndex:2}}>âŒ¨ï¸ Pfeiltasten</div>)}
        </div>
      </div>

      {/* VOICE OVERLAY */}
      {showVoice&&(
        <div style={{position:"absolute",inset:0,background:`${C.BG}f5`,backdropFilter:"blur(20px)",zIndex:100,
          display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center",gap:14,animation:"fadeIn .2s ease"}}>
          <button onClick={()=>{stopVoice();setShowVoice(false)}} style={{position:"absolute",top:12,right:12,width:28,height:28,borderRadius:"50%",border:`1px solid ${C.BD}`,background:C.S1,color:C.DM,cursor:"pointer",fontSize:12,display:"flex",alignItems:"center",justifyContent:"center"}}>âœ•</button>
          <div style={{fontFamily:"'Outfit'",fontSize:22,fontWeight:900,background:`linear-gradient(135deg,${C.R},${C.O})`,WebkitBackgroundClip:"text",WebkitTextFillColor:"transparent"}}>{listening?"Ich hÃ¶re zu...":"Sprechen"}</div>
          <canvas ref={waveRef} width={400} height={60} style={{borderRadius:8,border:`1px solid ${C.R}15`}} />
          {(transcript||interim)&&(
            <div style={{maxWidth:440,width:"100%",padding:"10px 14px",borderRadius:8,background:`${C.S1}cc`,border:`1px solid ${C.BD}`}}>
              <div style={{fontSize:12,fontFamily:"'Outfit'",lineHeight:1.5}}>{transcript&&<span>{transcript} </span>}{interim&&<span style={{color:C.DM,fontStyle:"italic"}}>{interim}</span>}</div>
              <div style={{marginTop:4,fontSize:10,color:C.O,fontFamily:"'Fira Code'"}}>â†’ {speechToCode(transcript||interim)}</div>
            </div>)}
          <div style={{display:"flex",gap:8}}>
            {listening
              ?<button onClick={stopVoice} style={{width:52,height:52,borderRadius:"50%",border:"none",cursor:"pointer",background:C.R,color:"#fff",fontSize:16,display:"flex",alignItems:"center",justifyContent:"center",animation:"breathe 1.5s ease infinite"}}>â¹</button>
              :<button onClick={startVoice} style={{width:52,height:52,borderRadius:"50%",border:`2px solid ${C.R}40`,cursor:"pointer",background:C.S1,color:C.R,fontSize:16,display:"flex",alignItems:"center",justifyContent:"center"}}>ğŸ¤</button>}
          </div>
          {transcript&&(
            <div style={{display:"flex",gap:5}}>
              <button onClick={()=>{const c=speechToCode(transcript);setCode(p=>p+(p&&!p.endsWith("\n")?"\n":"")+c);stopVoice();setShowVoice(false)}}
                style={{padding:"6px 14px",borderRadius:6,border:"none",cursor:"pointer",background:`linear-gradient(135deg,${C.O},${C.R})`,color:"#fff",fontFamily:"'Outfit'",fontSize:10,fontWeight:700}}>âœï¸ EinfÃ¼gen</button>
              <button onClick={()=>{sendToAI(transcript);stopVoice();setShowVoice(false)}}
                style={{padding:"6px 14px",borderRadius:6,border:"none",cursor:"pointer",background:`linear-gradient(135deg,${C.P},${C.B})`,color:"#fff",fontFamily:"'Outfit'",fontSize:10,fontWeight:700}}>ğŸ¤– An KI</button>
            </div>)}
        </div>)}

      {/* AI OVERLAY */}
      {showAI&&(
        <div style={{position:"absolute",inset:0,background:`${C.BG}f5`,backdropFilter:"blur(20px)",zIndex:100,
          display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center",gap:10,animation:"fadeIn .2s ease"}}>
          <button onClick={()=>setShowAI(false)} style={{position:"absolute",top:12,right:12,width:28,height:28,borderRadius:"50%",border:`1px solid ${C.BD}`,background:C.S1,color:C.DM,cursor:"pointer",fontSize:12,display:"flex",alignItems:"center",justifyContent:"center"}}>âœ•</button>
          <div style={{fontSize:30}}>ğŸ¦¢</div>
          <div style={{fontFamily:"'Outfit'",fontSize:18,fontWeight:900,background:`linear-gradient(135deg,${C.P},${C.B})`,WebkitBackgroundClip:"text",WebkitTextFillColor:"transparent"}}>Was soll ich erschaffen?</div>
          <div style={{display:"flex",flexWrap:"wrap",gap:3,justifyContent:"center",maxWidth:500}}>
            {["3D-Stadt mit Kugeln","Physik BÃ¤lle Demo","Partikel-Feuerwerk",
              "Pong-Spiel","Kamera-Steuerung","KI die Farben lernt",
              "Mehrspieler Cursor-Jagd","Plasma-Shader","SchildkrÃ¶te Mandala","Planetensystem"].map(s=>(
              <button key={s} onClick={()=>{setAiInput(s);sendToAI(s)}} style={{padding:"3px 9px",borderRadius:6,border:`1px solid ${C.BD}`,background:C.S1,color:C.TX,cursor:"pointer",fontSize:9.5,fontFamily:"'Outfit'"}}>{s}</button>))}
          </div>
          <div style={{display:"flex",gap:4,width:"100%",maxWidth:460}}>
            <input value={aiInput} onChange={e=>setAiInput(e.target.value)} onKeyDown={e=>{if(e.key==="Enter")sendToAI(aiInput)}}
              placeholder="Beschreibe was du willst..." style={{flex:1,padding:"9px 12px",borderRadius:8,border:`1px solid ${C.BD}`,background:`${C.S1}cc`,color:C.TX,fontSize:11,fontFamily:"'Outfit'"}} />
            <button onClick={()=>sendToAI(aiInput)} disabled={aiLoading}
              style={{padding:"9px 16px",borderRadius:8,border:"none",cursor:"pointer",
                background:aiInput.trim()?`linear-gradient(135deg,${C.P},${C.B})`:C.S1,
                color:aiInput.trim()?"#fff":C.DM,fontFamily:"'Outfit'",fontSize:11,fontWeight:700}}>
              {aiLoading?<span style={{animation:"spin .8s linear infinite",display:"inline-block"}}>â³</span>:"â†’"}</button>
          </div>
        </div>)}

      {/* STATUS */}
      <div style={{height:18,display:"flex",alignItems:"center",justifyContent:"space-between",
        padding:"0 12px",borderTop:`1px solid ${C.BD}30`,background:`${C.S1}80`,fontSize:7.5,color:C.DM,flexShrink:0}}>
        <div style={{display:"flex",gap:6,fontFamily:"'Outfit'"}}>
          <span style={{fontWeight:700}}>BLACK SWAN OMEGA</span>
          <span style={{color:isShader?C.P:is3D?C.B:isAnim?C.R:C.T}}>{modeLabel}</span>
          {camActive&&<span style={{color:C.O}}>ğŸ“·</span>}
        </div>
        <span style={{letterSpacing:0.3}}>ğŸ‘¥Multi Â· ğŸŒShader Â· ğŸ§Š3D Â· ğŸ–ï¸KÃ¶rper Â· ğŸ§ KI Â· âš›ï¸Physik Â· ğŸ­Partikel Â· ğŸ®Game Â· ğŸ¢Turtle Â· ğŸ”ŠSound Â· ğŸ“±Touch</span>
      </div>
    </div>
  );
}

try {
  const root = ReactDOM.createRoot(document.getElementById("root"));
  root.render(React.createElement(BlackSwan));
} catch(e) {
  document.getElementById("root").innerHTML = "<pre style='color:#f43f5e;padding:20px'>Error: " + e.message + "</pre>";
}
</script>
</body>
</html>